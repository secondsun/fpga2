#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement H
\paperfontsize default
\spacing other 1.5
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Title
\noindent
\begin_inset Graphics
	filename image/wpiLogo.png
	lyxscale 25
	scale 25

\end_inset


\begin_inset Newline linebreak
\end_inset


\series bold
FPGA-Based Graphics Acceleration
\series default

\begin_inset Newline linebreak
\end_inset

Project Proposal
\end_layout

\begin_layout Author
\paragraph_spacing single
\noindent
Eric Nadeau
\begin_inset Newline newline
\end_inset

Skyler Whorton
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
\align right
Professor R.
 James Duckworth
\begin_inset Newline linebreak
\end_inset


\series bold
Major Advisor
\series default

\begin_inset Newline linebreak
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
\align right
Professor Emmanuel Agu
\begin_inset Newline linebreak
\end_inset


\series bold
Co-Advisor
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Table of Contents}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{List of Figures}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{List of Tables}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
With the growing popularity of a wide variety of mobile and embedded devices
 capable of three-dimensional graphics, it's prudent to consider the direction
 of evolution of such devices.
 While many devices capable of realizing 3D graphics currently do so through
 the implementation of application-specific integrated circuit (ASIC) designs,
 it may be worth considering the implementation of field-programmable gate
 arrays (FPGA) for future designs of mobile 3D graphics devices.
 An FPGA design may implement a hardware descriptor language (HDL) and may
 be fully configurable, making this appealing to many developers.
 Because the FPGA is a relatively small and powerful type of chip, its applicati
ons are implicitly scalable and portable.
 These characteristics are ideal for mobile and embedded devices.
 Furthermore, the use of parallel processing on the FPGA is conducive to
 applications such as graphics rendering.
 For these main reasons, implementing FPGA designs to realize the rendering
 of 3D graphics in mobile devices could become a great advance over current
 ASIC technology.
\end_layout

\begin_layout Standard
Current technology trends have precipitated newer graphics processing units
 (GPUs) that can produce three 3D visualizations on compact and portable
 devices.
 These may reside on a single chip and can typically perform advanced 3D
 rendering techniques, including programmable pixel and vertex processors.
 However, such implementations are only realizable by the few major graphics
 hardware vendors.
 This is due to the massive cost and overhead of developing such devices.
 Furthermore, once such hardware is developed, it can no longer be customized
 or improved until a subsequent generation of chips.
 The requirements of such a design include some concrete implementation
 of the graphics pipeline, including all relevant input, output and processing
 hardware as well as device software.
 These requirements may be met using an FPGA-based design approach.
 
\end_layout

\begin_layout Standard
With such a design, the stages of the graphics pipeline and all of its necessary
 subsystems would be implemented on an FPGA using an HDL.
 Taking advantage of the FPGA's parallel nature, advanced 3D mathematical
 algorithms may be processed while other rendering operations are performed.
 The FPGA would also provide the hardware implementation of any input and
 output interfaces in addition to driving the display controller.
 A graphics application programming interface (API) would be adapted in
 software from an OpenGL library such as OpenGL ES, which provides a cross-platf
orm interface for 3D rendering on embedded systems.
 Such an implementation would allow communication with the FPGA via a custom
 device driver, dependent on the hardware chosen.
 This proposed project would furthermore implement the necessary test and
 benchmarking software modules to evaluate such a design, comparing its
 effectiveness against ASIC graphics accelerators.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Background Research
\end_layout

\begin_layout Standard
Before making any design decisions, it is vital to understand the current
 state of portable graphics hardware and technology.
 The chapter discusses what the graphics pipeline is and the necessary concerns
 that must be taken into consideration to make an implementation of one
 feasible on an FPGA.
 
\end_layout

\begin_layout Subsection
Graphics Rendering Pipeline
\end_layout

\begin_layout Standard
The graphics rendering pipeline traditionally refers to a generalized abstractio
n for the process that of which modern graphics processing units (GPUs)
 employ to produce visualizations.
 The GPU typically implements 6 stages within the pipeline, and often various
 substages within these.
 These 6 are: (1) the front end, (2) a vertex processing, (3) primitive
 assembly, (4) rasterization and interpolation, (5) fragment processing,
 and (6) frame buffer output.
 These stages all run in parallel, however it is important to note that
 data passes through each of them sequentially.
 Below shows the graphics pipeline, as implemented by OpenGL:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/graphicsPipeline.PNG
	lyxscale 50
	scale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A high level representation of the graphics pipeline used in realtime rendering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source Adapted from: NVIDIA Cg User's manual, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This figure shows all of the major components of the graphics rendering
 pipeline for modern GPUs.
 This pipeline typically starts at the front end, where commands and data
 are sent from a host system.
 The graphics data will then filter through the pipeline, while the GPU
 performs necessary processing and transformation to produce raw displayable
 data.
 The graphics commands typically control the how this processing and transformat
ion is done at the various stages.
 The output of this system is an image updating in realtime that can be
 drawn by a display device.
 This section describes the high level functionality of these stages, and
 how they interact with each other.
\end_layout

\begin_layout Subsubsection
Front End
\end_layout

\begin_layout Standard
With graphics hardware, a the front end provides the necessary interface
 for all commands and data to be sent to the GPU.
 Typically, this block consists of a number of different of different layers.
 At a most basic level, these are: (1) a device driver on the host system,
 (2) a hardware interface physically connecting the GPU to the host system,
 and (3) a command processor that receives and decodes commands and data
 from the hardware interface.
 After this third layer, decoded commands and data are then used to define
 the operations of the GPU and render visualizations by distributing them
 to the other components within the graphics hardware.
 It can be noted that can be implemented with just a write interface, however
 it is often advantageous to have certain read signals with many applications.
 The most important of these is for initiating an interrupt request upon
 completion of drawing a frame.
\end_layout

\begin_layout Subsubsection
Vertex Processing
\end_layout

\begin_layout Standard
With 3D graphics processing, a vertex is typically a vector of three numbers
 that represent a discrete position in space.
 These are often accompanied by many other vectors, representing such things
 as shading color, texture coordinates, or normal direction.
 The vertex processing block is responsible for decoding these data received
 by the GPU and preparing them to be assembled as primitives and then rasterized.
 For this to be done, the vertex positions must be transformed from the
 3D space that they are defined in to 2D space that can eventually be approximat
ed on a display device.
 This stage is referred to as perspective transformation, as it transforms
 objections to be drawn as they appear from the viewer's perspective.
 Additionally, this block will also transform vertex data within 3D dimensional
 space, providing hardware accelerated rotation, translation, and scaling
 of objects in space.
\end_layout

\begin_layout Subsubsection
Primitive Assembly
\end_layout

\begin_layout Standard
A primitive is one or more vertices making up a point, line, or polygon.
 This stage takes transformed vertices from perspective transformations
 during vertex processing stage to produce primitives.
 Primitives are then clipped to fit just within the viewport or view volume,
 and prepared to be rasterized to the display device.
 The primitive data are then typically passed from this stage to the rasterizer
 within some form of buffer.
\end_layout

\begin_layout Subsubsection
Rasterization and Interpolation
\end_layout

\begin_layout Standard
In computer graphics, a raster image is a 2D array of discrete pixels that
 represent intensity samples.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 As such, 
\shape italic
rasterization
\shape default
 is the stage within the graphics rendering pipeline where a 2D image is
 generated from transformed primitive data.
 More formally, rasterization is defined as converting a line drawing, mathemati
cal expression in space, or a 3D scene into intensity values to be written
 to an image buffer, which is then propagated to an output device.
 Within rasterization, 
\shape italic
interpolation
\shape default
 is the process of constructing new data points - in the form of color intensity
 values - within the discrete range connecting two vertices.
 With computer graphics, interpolation is necessary for generating vertex
 colors and fog, among other things.
 
\end_layout

\begin_layout Standard
When creating a rasterizer, there are two main challenges that designers
 are often faced with: (1) To determine the pixel(s) that accurately describe
 the current primitive being rendered, and (2) to be efficient.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 Furthermore, rasterization includes the process of 
\shape italic
clipping
\shape default
, which eliminates primitives that do not need to be rendered to the display
 device.
 These bounds are typically referred to as the 
\shape italic
culling object
\shape default
.
 Lastly, within the rasterization stage, the 
\shape italic
Z-buffer
\shape default
 (depth buffer) is generated, which stores the depth values for rasterized
 pixels.
 For this project, rasterization of primitives is limited to simply points,
 lines, and triangles.
 This section describes ideal algorithms using fixed-point mathematics for
 rasterizing these, as well as proper methods of clipping and Z-buffer generatio
n.
 
\end_layout

\begin_layout Subsubsection
Frame Buffer
\end_layout

\begin_layout Standard
After the GPU has produced a synthesized image, and performed necessary
 pixel transformation on it, the pixels are stored in an image buffer -
 the 
\shape italic
frame buffer
\shape default
.
 As its name suggests, the frame buffer stores the current 
\begin_inset Quotes eld
\end_inset

frame
\begin_inset Quotes erd
\end_inset

 to be rendered, in reference to an animation sequence.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 This intermediate storage between the graphics pipeline and the output
 display is necessary because the two are not synchronized with each other.
 Displays are typically clocked, which depend on both the display resolution
 and refresh rate.
 Display updates are synchronous processes, performing continuously and
 sequentially by a constant clock signal.
 The GPU, on the other hand, produces data asynchronously and randomly,
 which is dependent on when the CPU sends it data or commands.
\end_layout

\begin_layout Standard
The frame buffer for a graphics accelerator is generally either preallocated
 in a systems main memory, or in a dedicated memory device onboard the graphics
 accelerator.
 Specifically, with realtime graphics systems, the frame buffer is where
 all pixel color data from rasterization is stored before being drawn to
 the display.
 Furthermore, this is necessary because rasterization is performed on primitives
 and there is no guarantee that the rasterized primitives are actually drawn
 to the output.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 For simplicity and efficiency, pixel color data within the framebuffer
 is typically encoded in a format most compatible with the input signals
 of the display device.
\end_layout

\begin_layout Standard
Unfortunately, due to the conflict between GPUs random access to the frame
 buffer and the display device's sequential access, many issues arise.
 Primarily, it is very likely that the display device will begin reading
 a 
\shape italic
scanline
\shape default
, the a horizontal pixel line traced by a display's rasterbeam, before the
 GPU has finished drawing it.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 An ideal solution to this problem would be for the output circuit of the
 graphics accelerator to wait for the rendering of a frame to be completed
 before starting to read the frame buffer.
 However, this is not possible, as the output image must be updated at a
 very specific rate that is independent of rasterization time.
\end_layout

\begin_layout Standard
The solution to this problem is to introduce 
\shape italic
double buffering
\shape default
, the use of two frame buffers by the GPU.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 The first frame buffer, the back buffer, is used for writing only from
 the rasterizer, and can as such be written to randomly.
 The second framebuffer, the front buffer, is used only for reading from
 the output circuit, and can as such be read sequentially without respect
 to the time of which data is written.
 When the current frame is finished rendering to the back buffer, the two
 buffers then switch roles, and the next frame is drawn.
 This will prevent the buffer that is currently being drawn from ever being
 directly written to.
\end_layout

\begin_layout Standard
However, basic double buffering still may not correct all possible frame
 buffer related artifacts.
 The most common of these, 
\shape italic
tearing
\shape default
, occurs when the buffers swap before the sequential reading of the front
 buffer has not completed an entire frame.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 This results in the lower portion of the display being a frame ahead from
 the upper portion.
 Tearing can be avoided by only buffer swapping in the refresh interval,
 the vertical blank count (VBLANK), between the previous and next frames.
 Swapping during the VBLANK period will, however, introduce a lag.
 On many modern graphics accelerators, this is a setting that can be disabled
 in order to maximize speed.
\end_layout

\begin_layout Subsection
3D Mathematics
\end_layout

\begin_layout Standard
Graphics accelerators exist to implement the required mathematics to render
 3D visualizations more efficiently than computer CPUs.
 These mathematics are often complex and provide all of the necessary routines
 to formulate a 3D scene, and animate it as needed.
 This section describes the foundational concepts of these operations, as
 well as the necessary considerations for implementing such routines on
 an FPGA.
\end_layout

\begin_layout Subsubsection
Transformation
\end_layout

\begin_layout Standard
Modern computer graphics accelerators typically take advantage of highly
 optimized math co-processors to perform floating point transformations
 of objects in 3D space.
 Transformation is divided into two categories.
 The first of these is 
\shape italic
modelview
\shape default
 transformation, which provides the necessary operations to translate, rotate,
 and scale objects.
 The second of these is 
\shape italic
perspective
\shape default
 transformation, which transforms objects in 3D space so that they will
 appear on a 2D display as if they were being viewed from the camera's perspecti
ve.
 All of these transformations are implemented via matrix multiplications,
 with specially defined scale, rotate, translate, and perspective matrices.
 
\end_layout

\begin_layout Subsubsection
Fixed-Point Computations
\end_layout

\begin_layout Standard
Floating-point units (FPUs), the components of CPUs used to natively perform
 arithmetic operations on floating point numbers, are often not available
 on FPGAs and few and far between on low-power micocontrollers and microprocesso
rs.
 With these, floating point math may be implemented in software, or simply
 not used at all.
 On such devices, reasonable computational performance can likely be achieved
 using fixed-point arithmetic operations for 3D mathematics rather than
 a software-defined FPU.
\end_layout

\begin_layout Standard
With fixed-point arithmetic, the decimal point of a number is 
\begin_inset Quotes eld
\end_inset

fixed
\begin_inset Quotes erd
\end_inset

 before a specific digit.
 For example, during integer math, the decimal is placed after the least
 significant bit (LSB), meaning that there is no memory allocated for a
 possible fraction.
 In this scenario, the fraction is discarded and the result of a computation
 is rounded to simply whole numbers.
 However, it is possible to fix the decimal point at a different position
 within the number.
 This allows for fractions to be represented, even if they are still just
 rounded approximations.
 With this form of number representation, math can be done by a traditional
 arithmetic logic unit (ALU) and 3D vectors may still be approximated enough
 to render realistic visualizations.
 This incorporates simple integer math, along with some additional steps
 to account for the decimal point position.
 
\end_layout

\begin_layout Standard
For the application of 3D mathematics, it is seldom ideal to represent fixed
 numbers with equal allocation for both whole numbers and fractions.
\begin_inset CommandInset citation
LatexCommand cite
key "pendleton"

\end_inset

This is due to the frequent need for a signed most significant bit (MSB),
 which constrains the integer component of the number.
 Instead, a format such as 18.14 or 17.15 (in the format M.N, where M represents
 the integer component in bits and N represents the fractional component
 in bits) is often much more usable for 32-bit 3D fixed-point math.
 For 16-bit math, the format 10.6 is ideal to allow for a substantial enough
 integer component.
\end_layout

\begin_layout Subsection
Target Platforms
\end_layout

\begin_layout Standard
This project will require two target platforms, the FPGA development board
 for the system to be developed on, and the embedded system to serve as
 the host device that must utilize the graphics accelerator to render 3D
 visualizations.
 This section proposes the selected platforms and discusses how the selected
 devices meet the needs of the project.
\end_layout

\begin_layout Subsubsection
Spartan-6 FPGA and SP605 Evaluation Kit
\end_layout

\begin_layout Standard
The Spartan-6 is the latest iteration of Xilinx's Spartan family of low-cost,
 low-power FPGAs.
 Xilinx, the leading FPGA manufacturer, has designed the Spartan 6 with
 high performance and cost-sensitive applications in mind.
\begin_inset CommandInset citation
LatexCommand cite
key "spartan1"

\end_inset

 Using 45nm, 9-metal copper layer, dual-oxide process technology, the Spartan
 6 includes advanced power management and memory support, among other features.
 The selected LXT model includes 150,000 logic cells and supports integrated
 hard memory, block RAM, high performance clocking and serial IO, and an
 integrated PCI-Express (PCI-E) endpoint block.
 The Spartan-6 LTX is Xilinx's ideal offering for FPGA-based graphics accelerati
on as it balances both price-point and the resources necessary for GPU computati
ons.
 
\end_layout

\begin_layout Standard
The SP605 Evaluation Kit enables developers to easily prototype designs
 with the Spartan-6 LXT FPGA.
 The kit includes all the basic components of the Xilinx Base Targeted Design
 Platform in one package.
 
\begin_inset CommandInset citation
LatexCommand cite
key "spartan1"

\end_inset

 With the SP605, developers can easily take advantage of the features of
 the Spartan 6.
 Additionally, the kit includes DVI video output, a 200MHz oscillator, 128MB
 of DDR3 memory, and various expansion connections.
 The figure below shows the SP605 board.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/sp605.png
	lyxscale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spartan-6 SP605 Evaluation Kit
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source: http://www.xilinx.com/products/devkits/EK-S6-SP605-G.htm, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The support for the Spartan-6 LXT FPGA, digital video output interface,
 and 200MHz clock all make the SP605 a great choice for FPGA-based graphics
 acceleration.
 Additionally, its support for PCI-E makes it ideal for potential application
 in a desktop PC environment.
\end_layout

\begin_layout Subsubsection
Beagle Board
\end_layout

\begin_layout Standard
This project requires an embedded development system as a test platform
 for use with the FPGA-based GPU implementation.
 This test platform must meet the following requirements:
\end_layout

\begin_layout Enumerate
The platform must be a low-cost, low-power single-board computer (SBC)
\end_layout

\begin_layout Enumerate
The platform must be able to boot an embedded operating system (OS)
\end_layout

\begin_layout Enumerate
The platform must be fast enough to send graphics commands and data to the
 GPU in real-time
\end_layout

\begin_layout Enumerate
The platform must include a graphics chipset that can also render OpenGL
 ES 1.0 applications, for benchmarking purposes
\end_layout

\begin_layout Standard
The platform selected to fulfill these requirements was the Beagle Board,
 developed by Texas Instruments to demonstrate the the features of the OMAP3530
 system-on-a-chip (SoC).
 This SBC is both low-cost and low-power, retailing at only $149.00 USD per
 board.
\begin_inset CommandInset citation
LatexCommand cite
key "beagle1"

\end_inset

 The OMAP3530 meets both the second and third requirements, incorporating
 the ARM Cortex-A8 CPU, running at an impressive 720MHz and capable of booting
 Windows CE, Linux, and Symbian operating systems.
 Lastly, the Beagle Board incorporates the PowerVR SGX chipset, a OpenGL
 ES 2.0 capable 2D/3D graphics accelerator capable of rendering 10 million
 polygons per second.
 Meeting the fourth requirement, this GPU would allow parallel rendering
 to benchmark the quantitative and qualitative performance of the FPGA implement
ation.
 Below shows the Beagle Board and highlights its major features.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/beagleBoard.png
	lyxscale 50
	scale 70
	BoundingBox 2bp 2bp 463bp 300bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The Beagle Board and its feature set
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source: http://www.beagleboard.org, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Project Overview and Design
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
This chapter presents a general overview of the project, discussing its
 goal and the objectives that must be met.
 Additionally, this chapter proposes a high level design, describing how
 to implement the project's various components and meet the necessary design
 requirements.
\end_layout

\begin_layout Subsection
Goal
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The main goal of this project is to implement a portable graphics accelerator
 on a FPGA.
 This device should provide single-chip 3D graphics acceleration for low-power
 and space-conscious environments, such as with mobile and embedded systems.
 Implemented in Hardware Description Language (HDL), this accelerator would
 be entirely open and configurable, providing a graphics system that could
 be easily adapted or optimized for specific system requirements.
\end_layout

\begin_layout Subsection
Objectives
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
To achieve the goal of this project, three primary objectives must be met:
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must provide a simple and fast input interface
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must be able to generate an image at reasonable
 speeds from graphics data
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must provide a display output interface
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
These objectives will be completed through the design and implementation
 of a number of subsystems.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The first objective is for the device to interface with other systems that
 need to display graphics.
 The device should easily connect to other systems through a standard input/outp
ut (I/O) format, wherein it should use an easy and intuitive means of communicat
ion.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The second objective is the ability of the device to rasterize a two-dimensional
 (2D) image from the three dimensional (3D) data provided by another system.
 This must be accomplished efficiently because many images need to be generated
 per second to produce smooth animated visualizations.
 Consequently, the device must use optimal algorithms to perform these operation
s.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The third and final objective is to provide a means to display the generated
 image.
 This means should adhere to a standardized display format, allowing the
 graphics accelerator to be used with many different platforms.
 An output connection, as well as the underlying hardware controller for
 the selected format, should be provided.
\end_layout

\begin_layout Subsection
\paragraph_spacing onehalf
Design Requirements
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The design for this project includes 5 subsystems.
 These systems and their responsibilities are described in 
\series bold
Table 1
\series default
.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Provide a cross-platform interface for graphics commands and data.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Graphics Processor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Render 3D primitive data to a 2D pixel buffer.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implement a standardized display output.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Graphics API
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Allow a user to easily transmit graphics data from their applications.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Device Driver
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Provide the interface between software and the graphics hardware.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The major components of the design requirements
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
Each subsystem has its own specific requirements.
 The 
\shape italic
input interface
\shape default
 must provide a communication connection for graphics commands and data
 to the accelerator.
 This hardware implements the link between a host system and the the graphics
 processing unit (GPU).
 This interface must be independent of the platform used with the accelerator,
 adhering to a known and standardized I/O format.
 This format must be able to transfer graphics commands and data at a fairly
 high rate while being compatible with a reasonable amount of low-power
 microprocessor and microcontroller systems.
 This is intended for easy application with a multitude of mobile platforms.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The 
\shape italic
graphics processor
\shape default
 shall render 3D primitive data to 2D space and will be fulfilled by the
 functional implementation of a GPU.
 The GPU must implement the 3D graphics pipeline and all of its components.
 The GPU must be able to receive encoded commands and data from the input
 interface, perform transformations on these, and rasterize the result to
 a raw pixel buffer.
 These components must run efficiently and integrate seamlessly with the
 desired input and output devices.
 The GPU must implement optimal rasterization and transformation algorithms
 that run in parallel to each other and achieve the highest possible speeds
 for the target platform.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
output interface
\shape default
 must implement a standardized display output, providing the interface between
 the GPU and a target output device.
 This interface must implement a digital video out standard ensuring that
 it could be used for multiple different displays.
 This requires a hardware implementation of the display format controller
 to generate necessary output signals.
 Furthermore, this requires the necessary hardware to provide a physical
 display output connection.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
graphics API
\shape default
 (Application Programming Interface) must define an abstraction layer that
 allows a user to easily send graphics commands and data to the accelerator
 from their applications.
 This API must be implemented in a standardized programming language and
 must follow a consistent and logical specification.
 The API must implement all configuration of all graphics features and settings
 of the accelerator.
 The API must also provide an intuitive interface for drawing and manipulating
 graphical data using the GPU.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
device driver
\shape default
 provides the software interface between the graphics API and the hardware
 input interface.
 The driver must implement the defined functionality of the API by sending
 commands and data to the input interface.
 This driver must be compatible with multiple hardware systems by being
 implemented within a standard driver model.
 
\end_layout

\begin_layout Subsection
Design
\end_layout

\begin_layout Standard
This section describes the overall system design for the project, implementing
 the requirements previously discussed.
 The core of the system, the graphics processor and all of its necessary
 subsystems, will be implemented within the Spartan-6 LXT FPGA on the SP605
 Development Board.
 
\end_layout

\begin_layout Standard
To render 3D visualizations, data will flow first from the application,
 then to the graphics API and driver, and then to the FPGA.
 The FPGA will perform all necessary processing to rasterize the 3D visualizatio
ns to a framebuffer located in memory.
 The selected device to hold video memory is the 128MB DDR3 component memory,
 located on the SP605.
 Next, data from the framebuffer will be synchronously sent to the display
 device, using the SP605's Digital Video Interface (DVI) control circuitry.
 The figure below provides a simple overall system diagram of the graphic
 hardware and its input and output interfaces.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/systemDiagram.png
	lyxscale 75
	scale 55
	BoundingBox 3bp 3bp 645bp 522bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
System overview
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Software Design Overview
\end_layout

\begin_layout Standard
The software design for this project implements all of the necessary abstraction
s for an application programmer to render 3D data with the graphics accelerator.
 This consists of two primary subsystems, (1) the graphics API and (2) the
 device driver.
 Additionally, the software designs for this project include various test
 modules whose purpose is to qualitatively and quantitatively benchmark
 the FPGA-based graphics accelerator against similar performing ASIC-based
 graphics devices.
 
\end_layout

\begin_layout Paragraph
Graphics API
\end_layout

\begin_layout Standard
The graphics API is the software interface to the graphics hardware, allowing
 3D visualizations to be drawn for an application by invoking a logical
 and standardized set of functions.
 To be streamlined and hardware independent, the choice was made to implement
 OpenGL ES 1.0 as the graphics API, rather than designing a custom software
 interface.
 However, due to the limited scope of this project, only those functions
 that can be defined within the constraints of the graphics hardware features
 will be implemented.
 The remaining functions will be implemented as 
\begin_inset Quotes eld
\end_inset

stubs
\begin_inset Quotes erd
\end_inset

, allowing possible future expandability and for OpenGL ES applications
 to be compiled.
\end_layout

\begin_layout Paragraph*
Driver
\end_layout

\begin_layout Standard
The driver will perform all communication between the application (or operating
 system) and the graphics hardware.
 The driver will either run in (A) user space or (B) kernel space, dependent
 on the chosen I/O format.
 Presently, potentially feasible I/O formats are being explored, including:
 General Purpose I/O (GPIO), Serial Peripheral Interface (SPI), PCI-Express,
 and Universal Serial Bus (USB).
 If implemented in kernel space, the driver will follow a known driver model
 (Linux or Windows).
 If implemented in user space, the driver may potentially be implemented
 as a linked library to be included with an application utilizing the graphics
 hardware.
 This decision will be made once a final input interface platform is decided
 upon.
\end_layout

\begin_layout Paragraph*
Test Modules
\end_layout

\begin_layout Standard
The series of test modules will be written in order to qualitatively and
 quantitatively benchmark the graphics hardware.
 These will be written as 3D demos, and perform the following:
\end_layout

\begin_layout Itemize
Identify the maximum performance limitations of the graphics hardware, and
 produce reports on these (triangles-per-second, etc.)
\end_layout

\begin_layout Itemize
Implement tests to demonstrate and validate each individual feature of the
 graphics hardware
\end_layout

\begin_layout Itemize
Create a final, presentable, 3D visualization that takes full advantage
 of the graphics hardware to produce an animated scene, demonstrating all
 of the capabilities of the system
\end_layout

\begin_layout Subsubsection
RTL Design Overview
\end_layout

\begin_layout Standard
The Register Transfer Level (RTL) design for the graphics accelerator implements
 a number of subsystems to control the various stages of the graphics pipeline
 and its necessary input and output interfaces.
 The figure below provides a system diagram for the RTL hardware design
 of the project.
 This system performs the necessary steps to render 3D graphics to an output
 display device from an input command stream, provided by the host controller,
 a microcontroller or a microprocesser system.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/rtl_overview.png
	lyxscale 70
	scale 60
	BoundingBox 5bp 5bp 765bp 660bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
RTL design overview
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To control the graphics accelerator, commands must first be pushed into
 the GPU by the device driver running on the host system, followed directly
 by any relevant data.
 The GPU then disperses the commands and data to the necessary subsystems,
 specifically the 
\shape italic
Vertex and Transformation Unit
\shape default
 (VTU) and the 
\shape italic
Rasterizer
\shape default
 (RAS).
 These two units run in parallel, albeit sequentially on data.
 Transformed and rasterized data are then read sequentially by the 
\shape italic
Video Interface
\shape default
 (VI), which runs independently of the other subsystems, constantly refreshing
 the output display device signals.
 Below shows an example execution for a program that draws simple 3D primitives
 with the proposed implementation.
\end_layout

\begin_layout Enumerate
Initialization routine
\end_layout

\begin_deeper
\begin_layout Enumerate
Set clear color and depth values
\end_layout

\begin_layout Enumerate
Set viewport
\end_layout

\begin_layout Enumerate
Set view transformation mode (perspective, orthogonal)
\end_layout

\end_deeper
\begin_layout Enumerate
Draw primitives
\end_layout

\begin_deeper
\begin_layout Enumerate
Translate, scale, and rotate the modelview matrix
\end_layout

\begin_layout Enumerate
Send vertex position and color data
\end_layout

\end_deeper
\begin_layout Enumerate
Wait for vertical synchronization
\end_layout

\begin_layout Enumerate
Repeat steps 2 and 3
\end_layout

\begin_layout Paragraph
Graphics Processing Unit
\end_layout

\begin_layout Standard
The GPU processes the stream of data and commands (instructions) sent to
 the graphics accelerator.
 Acting as the frontend for the entire system, the GPU implements the various
 instructions needed to control the states of the remaining subsystems and
 draw primitive data.
 These instructions are queued into the GPU by a First-In First-Out (FIFO)
 buffer, and decoded and executed sequentially by the GPU.
 Consequently, the FIFO stores the sequence of instructions to be executed,
 as well as the necessary data these commands provide to the graphics accelerato
r.
 The GPU instruction set that defines all control over the graphics accelerator
 is presented below.
 
\end_layout

\begin_layout Standard
\paragraph_spacing single
\noindent
\begin_inset Tabular
<lyxtabular version="3" rows="27" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
00h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
NOP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
No operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
01h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DISPCNT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set GPU control register
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
02h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DISPSTAT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set GPU status register
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
03h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DRAWDONE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Denotes the end of a frame being drawn (swaps buffers)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
04h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VIEWPORT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Sets the viewport
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
05h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLEAR_COLOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Sets the clear color
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
06h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLEAR_DEPTH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Sets the clear depth
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
07h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
PIXEL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Draws a pixel directly to the framebuffer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
10h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_MODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set the current matrix mode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
11h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_PUSH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Push current matrix onto the stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
12h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_POP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Pop current matrix from the stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
13h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_STORE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Store current matrix on the stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
14h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_LOAD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Load current matrix from the stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
15h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_LOAD_I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Load current matrix with the identity matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
16h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_LOAD_4x4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Load a 4x4 matrix to the current matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
17h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_MULT_4x4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Multiply current matrix by a 4x4 matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
18h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_SCALE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Multiply current matrix by a scale matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
19h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_TRANS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Multiply current matrix by a translation matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
20h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_BEGIN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Begin a vertex list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
21h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_END
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
End a vertex list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
22h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_ATTRIB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set the attributes of the next vertex list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
23h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_POS_U16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set XYZ vertex coordinates, unsigned 16-bit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
24h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_POS_S16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set XYZ vertex coordinates, signed 16-bit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
25h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_POS_REL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set XYZ vertex coordinates, relative to the last vertex
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
26h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_COL_5551
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set RGBA vertex color, 5551 mode (16-bit)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
For the graphics accelerator to process a command, the opcode must first
 be sent to the FIFO, followed by its necessary fields.
 
\end_layout

\begin_layout Paragraph
Vertex and Transformation Unit
\end_layout

\begin_layout Standard
The Vertex and Transformation Unit defines two primary subsystems, (1) the
 Matrix Processor (MP), and (2) the Geometry Processor (GP).
 All VTX and MTX commands decoded by the GPU are processed by the VTU.
 
\end_layout

\begin_layout Standard
The Matrix Processor implements all matrix commands, as well as the two
 matrix stacks (modelview and projection), and stores the corresponding
 current matrices.
 The matrix stacks are stored in video RAM (VRAM) and each contain space
 for up to 256 stored matrices.
 Consequently, the stack is addressed by an 8-bit stack pointer.
 The MP implements all of its matrix transformations by multiplying the
 current matrix by another matrix, which can be defined for translation,
 scaling, rotation, or orthogonal and perspective projection.
 All matrices are 4x4 32-bit fixed point, with the fractional part in the
 lower 12 bits (signed 20.12 format).
\end_layout

\begin_layout Standard
The Geometry Processor performs all of the necessary routines to prepare
 incoming vertex streams to be rasterized to the frame buffer.
 Upon receiving a VTX_BEGIN command, the GP begins processing a vertex list
 of the specified primitive type (points, lines, or triangles).
 To do this, the VTU invokes the following sequence of events:
\end_layout

\begin_layout Enumerate
Upon receiving the VTX_BEGIN command, the VTU enters geometry processing
 mode, and cannot receive any non-VTX commands until completion.
\end_layout

\begin_layout Enumerate
The VTU then receives the VTX_ATTRIB command (or otherwise uses data from
 the most recently received VTX_ATTRIB) to specify how the primitives are
 to be processed.
\end_layout

\begin_layout Enumerate
The VTU then receives a VTX_POS command for the specified X, Y, and Z vertices
 of a primitive, and executes the following:
\end_layout

\begin_deeper
\begin_layout Enumerate
Transform the X, Y, and Z vertices of the primitive by the modelview matrix
 (using the matrix multiplier)
\end_layout

\begin_layout Enumerate
Transform the X, Y, and Z vertices of the primitive by the projection matrix
 (using the matrix multiplier)
\end_layout

\begin_layout Enumerate
Write the resulting 2D primitive X and Y values to vertex bank 0 (VBANK0)
 in VRAM if it is within the bounds of the framebuffer.
\end_layout

\begin_layout Enumerate
Write the Z distance from the current view to VBANK0.
\end_layout

\begin_layout Enumerate
Write the vertex color from the corresponding VTX_COL command immediately
 after the transformed X, Y, and Z values.
\end_layout

\end_deeper
\begin_layout Enumerate
The VTU then repeats step 3 for the remaining vertices that have been sent.
\end_layout

\begin_layout Enumerate
The VTU then exits geometry processing mode upon receiving the VTX_END command.
\end_layout

\begin_layout Standard
At the completion of all drawing, the VTU will wait for being signaled that
 drawing of the current frame is completed with the DRAWDONE command.
 At this time, VBANK0 and VBANK1 will be swap addresses, indicating that
 the data in VBANK1 is ready to be rasterized.
 The data in the new VBANK0 are then cleared before new writes from the
 GP occur.
\end_layout

\begin_layout Paragraph
Rasterizer
\end_layout

\begin_layout Standard
The Rasterizer's main purpose is to perform all of the drawing to the framebuffe
r.
 The RAS performs this in two steps, (1) primitive rasterization, the process
 of computing the necessary pixels to be written to approximate points,
 lines, and triangles, and (2) color rasterization, the process of determining
 the necessary pixel color via interpolation.
 The rasterizer reads data from VBANK1 upon being signaled by the DRAWDONE
 command from the GPU.
 At this time, the RAS rasterizes all vertices in VBANK1 to the framebuffer,
 invoking the necessary rastization algorithm depending on the current primitive
 type.
 
\end_layout

\begin_layout Standard
Before pixels are actually written to the framebuffer, the RAS compares
 the Z-distance from the view of the current vertex (stored in VBANK1) to
 the Z-value of the current pixel being drawn in the Z-buffer (stored in
 VRAM).
 If the pixel to be drawn is further away from the current view than the
 value in the Z-buffer, then it is not drawn to the framebuffer.
 If it is closer, than it is drawn, and the value in the Z-buffer is overwritten
 with the new Z value.
 This implements simple depth-sorting.
 The Z-buffer is then cleared at the end of the frame.
 
\end_layout

\begin_layout Standard
Upon completion of rasterization, the rasterizer then waits until the Video
 Interface enters the vertical blanking period, the time between two frames
 are being drawn to the display device.
 During this window, framebuffers 0 and 1 swap addresses, and the new framebuffe
r 0 is subsequently cleared.
 The Rasterizer then waits for the next DRAWDONE to begin rasterizing the
 next frame to this buffer.
\end_layout

\begin_layout Paragraph*
Video Interface
\end_layout

\begin_layout Standard
The Video Interface provides all of the necessary interfacing to the output
 display device.
 This primarily includes, (1) timing synchronization of the whole system
 with the display rate, and (2) sequential generation of the RGB signals
 to the output display device from framebuffer 1.
 The VI operations completely independent of the entire system on its own
 60 frames-per-second (FPS) clock, constantly outputting the data from framebuff
er 1 synchronously with the vertical and horizontal timing signals.
 The VI feeds back a single active-high control signal to the GPU, indicating
 when it is in the VBLANK phase, for synchronization purposes.
\end_layout

\begin_layout Subsection*
\noindent
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Appendix A: Detailed Project Schedule}
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Appendix A: Detailed Project Schedule
\end_layout

\begin_layout Standard
The implementation of this project will be completed between August and
 December of 2010.
 It has been broken up into 4 phases.
 These are: (1) development, (2) test and benchmarking, and (3) documentation.
 This section describes each of these phases, as well as a detailed timeline
 for the project.
\end_layout

\begin_layout Subsection*
Development Phase
\end_layout

\begin_layout Standard
The development phase deals specifically with implementing the hardware
 and software designs for the FPGA-based graphics accelerator.
 The phase will begin in early August and last until the end of October,
 which primarily consists of term A10.
 With this phase, it is the team's goal to ensure that all necessary hardware
 input interfaces are implemented prior to September such that software
 can be developed starting A10.
 Furthermore, to ensure that software and hardware development be independent
 of each other, a software-based graphics accelerator simulator will be
 implemented over the course of the summer (See Appendix B).
\end_layout

\begin_layout Subsection*
Test and Benchmarking Phase
\end_layout

\begin_layout Standard
The test and benchmarking phase deals specifically with evaluating the implement
ation of the graphics accelerator and its software interfaces.
 This phase will begin at the end of October and span the month of November,
 consisting mainly of the first half of term B10.
 With this phase, it is the team's goal to ensure that the implementation
 meets all of the proposed requirements.
 Furthermore, this phase will evaluate the qualitative and quantitative
 performance of the implementation, comparatively to other portable graphics
 devices.
 
\end_layout

\begin_layout Subsection*
Documentation Phase
\end_layout

\begin_layout Standard
The documentation phase is the last section of the project deals specifically
 with documenting the entire implementation of the project, and producing
 a coherent report from this.
 Furthermore, this report will provide all of the necessary background,
 proposed design, and other supplemental information for this project.
 This phase will officially begin at the end of November, and last until
 the end of term B10, December 16th.
 However, this phase is more specifically devoted to finalizing the report
 and adding lacking sections to it, as the report will slowly be developed
 over the course of the entire project.
\end_layout

\begin_layout Subsection*
Gantt Chart
\end_layout

\begin_layout Standard
This section presents the detailed timeline for the project schedule.
 The schedule is broken down by phase, and each phase is then broken down
 by each component of the project.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename image/gantt-page1.png
	lyxscale 25
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename image/gantt-page2.png
	lyxscale 25
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Appendix B: Graphics Accelerator Simulator
 (GA-SIM)}
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Appendix B: Graphics Accelerator Simulator (GA-SIM)
\end_layout

\begin_layout Standard
The graphics accelerator simulator (GA-SIM) is a software implementation
 of the proposed hardware design that will allow the software components
 of the project to be developed independent of the actual hardware implementatio
n.
 This simulator will accomplish this by implementing a software renderer
 that has all of the proposed functionality of the hardware and uses the
 same command write interface for render control.
 With GA-SIM, the graphics API and test module components of the project
 will be able to be fully implemented and tested without the needing the
 actual FPGA interfaces.
 Additionally, GA-SIM allows for a more finalized design to be better realized
 by providing a test bed for implementing and debugging graphics algorithms
 and other design decisions.
 Furthermore, it provides a benchmark to compare with the hardware implementatio
n.
\end_layout

\begin_layout Subsection*
Current Implementation
\end_layout

\begin_layout Standard
At the time of this report submission, most components of GA-SIM have been
 completed.
 While GA-SIM has a planned development period of July to August, it will
 be completed well in advance of this period.
 Currently, the following has been implemented:
\end_layout

\begin_layout Itemize
The 
\series bold
Video Interface
\series default
, with a 16-bit framebuffer and double-buffering and a simulated VBLANK
 period, which uses Simple DirectMedia Layer (SDL) for windowing and graphics
 output, allowing for cross-compatibility.
\end_layout

\begin_layout Itemize
The 
\series bold
Rasterizer
\series default
, which incorporates fixed-point rasterization algorithms for lines, triangles,
 and points, as well as 16-bit color interpolation.
\end_layout

\begin_layout Itemize
The 
\series bold
Graphics Processing Unit
\series default
 command interface, with a fully simulated FIFO and data write, and command
 decoding for all proposed commands.
\end_layout

\begin_layout Subsection*
Example Use
\end_layout

\begin_layout Standard
Using GA-SIM is very simple.
 To alternate between the simulator the and the actual hardware device driver
 that will be implemented, the C++ test module or graphics API must simply
 define or undefine the identifier 
\family typewriter
USE_GRAPHICS_ACCELERATOR_EMU
\family default
.
 Both the simulator and the driver will implement the same write interface,
 and as such no further code changes will need to be made.
 Below shows a simple code example that will draw a pixel to the framebuffer
 using the PIXEL command with the simulator (and future device driver) interface
:
\end_layout

\begin_layout Standard
\paragraph_spacing single
\noindent
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},numbers=left,numberstyle={\small}"
inline false
status open

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

// Initialize subsystems 	
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

GPU_OPEN();
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

Vertex myPixel; 	
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

myPixel.x._u16 = myPixel.y._u16 = 10; 	
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

myPixel.col.rgba = 0x001f;
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

// Main demo loop 	
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

for(;;) { 		
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

	// Push the PIXEL command into the FIFO 		
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

	GPU_FIFO_PUT8(PIXEL);
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

	// Push the PIXEL command parameters into the FIFO 		
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

	GPU_FIFO_PUT16(myPixel.x._u16); // Pixel x-coord 		
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

	GPU_FIFO_PUT16(myPixel.y._u16); // Pixel y-coord 	
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

	GPU_FIFO_PUT16(myPixel.col.rgba); // Pixel 16-bit color
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

	
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

	// Push the DRAWDONE command into the FIFO (Swap buffers) 		
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

	GPU_FIFO_PUT8(DRAWDONE); 	
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This simple code excerpt demonstrates the basic nature of communication
 with the graphics accelerator, regardless of hardware or simulation.
 Both GA-SIM and the driver will implement 
\family typewriter
GPU_OPEN
\family default
 to initialize the hardware, as well as 
\family typewriter
GPU_FIFO_PUT
\family default
 to push commands and data into the FIFO queue to be processed sequentially
 by the GPU.
 Data can be pushed in as a byte, halfword, or word, however the device
 driver simply implements these as multiple 8-bit FIFO pushes.
 As described in the design chapter, these low level command calls will
 be abstracted by the graphics API implementation, such that a programmer
 using the graphics accelerator will not access them directly.
 At the time of this proposal, the above demo has been implemented and tested
 within GA-SIM.
 The figure below shows a similar but more complex demo, drawing a shaded
 triangle as it would appear on the actual graphics hardware.
 
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/ga-sim01.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
GA-SIM Running a simple triangle rasterization demo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "reference_list"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
