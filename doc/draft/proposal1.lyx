#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement H
\paperfontsize default
\spacing other 1.5
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
\paragraph_spacing single
\noindent
\begin_inset Graphics
	filename image/wpiLogo.png
	lyxscale 25
	scale 25

\end_inset


\begin_inset Newline linebreak
\end_inset


\series bold
FPGA-Based Graphics Acceleration
\series default

\begin_inset Newline linebreak
\end_inset

Project Proposal
\end_layout

\begin_layout Author
\paragraph_spacing single
\noindent
Eric Nadeau
\begin_inset Newline newline
\end_inset

Skyler Whorton
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
\align right
Professor R.
 James Duckworth
\begin_inset Newline linebreak
\end_inset


\series bold
Major Advisor
\series default

\begin_inset Newline linebreak
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
\align right
Professor Emmanuel Agu
\begin_inset Newline linebreak
\end_inset


\series bold
Co-Advisor
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Itemize
TODO
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Background Research
\end_layout

\begin_layout Subsection
Portable Graphics
\end_layout

\begin_layout Subsubsection
Historical Context
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Applications
\end_layout

\begin_layout Itemize
Mobile Computing
\end_layout

\begin_layout Itemize
Embedded Systems
\end_layout

\begin_layout Subsubsection
Current ASIC Technology
\end_layout

\begin_layout Itemize
NVIDIA Tegra
\end_layout

\begin_layout Itemize
PowerVR SGX
\end_layout

\begin_layout Subsubsection
OpenGL ES
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
Graphics Rendering Pipeline
\end_layout

\begin_layout Standard
The graphics rendering pipeline traditionally refers to a generalized abstractio
n for the process that of which modern graphics processing units (GPUs)
 employ to produce visualizations.
 The GPU typically implements 6 stages within the pipeline, and often various
 substages within these.
 These 6 are: (1) the front end, (2) a vertex processing, (3) primitive
 assembly, (4) rasterization and interpolation, (5) fragment processing,
 and (6) frame buffer output.
 These stages all run in parallel, however it is important to note that
 data passes through each of them sequentially.
 Figure 1 below shows the graphics pipeline, as implemented by OpenGL:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/graphicsPipeline.PNG
	lyxscale 50
	scale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A high level representation of the graphics pipeline used in realtime rendering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source Adapted from: NVIDIA Cg User's manual, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This figure shows all of the major components of the graphics rendering
 pipeline for modern GPUs.
 This pipeline typically starts at the front end, where commands and data
 are sent from a host system.
 The graphics data will then filter through the pipeline, while the GPU
 performs necessary processing and transformation to produce raw displayable
 data.
 The graphics commands typically control the how this processing and transformat
ion is done at the various stages.
 The output of this system is an image updating in realtime that can be
 drawn by a display device.
 This section describes the high level functionality of these stages, and
 how they interact with eachother.
\end_layout

\begin_layout Subsubsection
Front End
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Vertex Processing
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Primitive Assembly
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Rasterization and Interpolation
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Fragment Processing
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Frame Buffer
\end_layout

\begin_layout Standard
After the GPU has produced a synthesized image, and performed necessary
 pixel transformation on it, the pixels are stored in an image buffer -
 the 
\shape italic
frame buffer
\shape default
.
 As its name suggests, the frame buffer stores the current 
\begin_inset Quotes eld
\end_inset

frame
\begin_inset Quotes erd
\end_inset

 to be rendered, in reference to an animation sequence.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 This intermediate storage between the graphics pipeline and the output
 display is necessary because the two are not synchronized with eachother.
 Displays are typically clocked, which dependent on both the display resolution
 and refresh rate.
 Display updates are synchronous processes, performing continuously and
 sequentially by a constant clock signal.
 The GPU, on the other hand, produces data asynchronously and randomly,
 which is dependent on when the CPU sends it data or commands.
\end_layout

\begin_layout Standard
The frame buffer for a graphics accelerator is generally either preallocated
 in a systems main memory, or in a dedicated memory device onboard the graphics
 accelerator.
 Specifically, with realtime graphics systems, the frame buffer is where
 all pixel color data from rasterization is stored before being drawn to
 the display.
 Furthermore, this is necessary because rasterization is performed on primitives
 and there is no guarantee that the rasterized primitives are actually drawn
 to the output.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 For simplicity and efficiency, pixel color data within the framebuffer
 is typically encoded in a format most compatible with the input signals
 of the display device.
\end_layout

\begin_layout Standard
Unfortunately, due to the conclict between GPU's random access to the frame
 buffer and the display device's sequential access, many issues arrise.
 Primarily, it is very likely that the display device will begin reading
 a 
\shape italic
scanline
\shape default
, the a horizontal pixel line traced by a display's rasterbeam, before the
 GPU has finished drawing it.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 An ideal solution to this problem would be for the output circuit of the
 graphics accelerator to wait for the rendering of a frame to be completed
 before starting to read the frame buffer.
 However, this is not possible, as the output image must be updated at a
 very specific rate that is independent of rasterization time.
\end_layout

\begin_layout Standard
The solution to this problem is to introduce 
\shape italic
double buffering
\shape default
, the use of two frame buffers by the GPU.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 The first frame buffer, the back buffer, is used for writing only from
 the rasterizer, and can as such be written to randomly.
 The second framebuffer, the front buffer, is used only for reading from
 the output circuit, and can as such be read sequentially without respect
 to the time of which data is written.
 When the current frame is finished rendering to the back buffer, the two
 buffers then switch roles, and the next frame is drawn.
 This will prevent the buffer that is currently being drawn from ever being
 directly written to.
\end_layout

\begin_layout Standard
However, basic double buffering still may not correct all possible frame
 buffer related artifacts.
 The most common of these, 
\shape italic
tearing
\shape default
, occurs when the buffers swap before the sequential reading of the front
 buffer has not completed an entire frame.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 This results in the lower portion of the display being a frame ahead from
 the upper portion.
 Tearing can be avoided by only buffer swapping in the refresh interval,
 the vertical blank count (VBLANK), between the previous and next frames.
 Swapping during the VBLANK period will, however, introduce a lag.
 On many modern graphics accelerators, this is a setting that can be disabled
 in order to maximize speed.
\end_layout

\begin_layout Subsection
3D Mathematics
\end_layout

\begin_layout Subsubsection
Transformation
\end_layout

\begin_layout Itemize
Model space -> scaling, rotation, translation
\end_layout

\begin_layout Itemize
View space -> perspective, orthogonal
\end_layout

\begin_layout Subsubsection
Fixed-Point Computations
\end_layout

\begin_layout Standard
Floating-point units (FPUs), the components of CPUs used to natively perform
 arithmatic on floating point numbers, are often not available on FPGAs
 and few and far between on low-power micocontrollers and microprocessors.
 With these, floating point math may be implemented in software, or simply
 not used at all.
 On such devices, reasonable computational performance can likely be achieved
 using fixed-point arithmatic for 3D mathematics rather than a software-defined
 FPU.
\end_layout

\begin_layout Standard
With fixed-point arithmatic, the decimal point of a number is 
\begin_inset Quotes eld
\end_inset

fixed
\begin_inset Quotes erd
\end_inset

 before a specific digit.
 For example, during integer math, the decimal is placed after the least
 signicant bit (LSB), meaning that there is no memory allocated for a possible
 fraction.
 In this scenerio, the fraction is discarded and the result of a computation
 is rounded to simply whole numbers.
 However, it is possible to fix the decimal point at a different position
 within the number.
 This allows for fractions to be represented, even if they are still just
 rounded approximations.
 With this form of number representation, math can be done by a tradional
 arithmatic logic unit (ALU), and 3D vectors can be approximated enough
 to render still realistic visualizations.
 This incorporates simple integer math, along with some additional steps
 to account for the decimal point position.
 Below describes these additional steps that must be taken depending on
 the operation performed: 
\end_layout

\begin_layout Itemize

\series bold
Addition
\series default
- TODO
\end_layout

\begin_layout Itemize

\series bold
Subtraction
\series default
- TODO
\end_layout

\begin_layout Itemize

\series bold
Multiplication
\series default
- TODO
\end_layout

\begin_layout Itemize

\series bold
Division
\series default
- TODO
\end_layout

\begin_layout Standard
For the application of 3D mathematics, it is often not ideal to represent
 fixed numbers with equal allocation for both whole numbers and and fractions.
\begin_inset CommandInset citation
LatexCommand cite
key "pendleton"

\end_inset

This is due to the need to often include a signed most significant bit (MSB),
 which constrains the integer component of the number.
 Intead, a format such as 18.14 or 17.15 (in the format M.N, where M represents
 the integer component in bits and N represents the fractional component
 in bits) is often much more usable for 32-bit 3D fixed-point math.
 For 16-bit math, the format 10.6 is ideal to allow for a substantial enough
 integer component.
\end_layout

\begin_layout Subsection
Target Platforms
\end_layout

\begin_layout Subsubsection
Field Programmable Gate Arrays (FPGAs)
\end_layout

\begin_layout Itemize
Overview of technology
\end_layout

\begin_layout Itemize
Advantages and disadvantages for graphics acceleration
\end_layout

\begin_layout Subsubsection
Spartan-6 FPGA and SP605 Evaluation Kit
\end_layout

\begin_layout Standard
The Spartan-6 is the latest iteration of Xilinx's Spartan family of low-cost,
 low-power FPGAs.
 Xilinx, the leading FPGA manufacturer, has designed the Spartan 6 with
 high performance and cost-sensitive applications in mind.
\begin_inset CommandInset citation
LatexCommand cite
key "spartan1"

\end_inset

 Using 45nm, 9-metal copper layer, dual-oxide process technology, the Spartan
 6 includes advanced power management and memory support, among other features.
 The selected LXT model boasts 150,000 logic cells and supports integrated
 hard memory, block RAM, high performance clocking and serial IO, and an
 integrated PCI-Express (PCI-E) endpoint block.
 The Spartan-6 LTX is Xilinx's ideal offering for FPGA-based graphics accelerati
on as it balances both pricepoint and the resources necessary for GPU computatio
ns.
 
\end_layout

\begin_layout Standard
The SP605 Evaluation Kit enables developers to easily prototype designs
 with the Spartan-6 LXT FPGA.
 The kit includes all the basic components of the Xilinx Base Targeted Design
 Platform in one package.
 
\begin_inset CommandInset citation
LatexCommand cite
key "spartan1"

\end_inset

 With the SP605, developers can easily take advantage of the features of
 the Spartan 6.
 Additionally, the kit includes DVI video output, a 200MHz oscillator, 128MB
 of DDR3 memory, and various expansion connections.
 Below, 
\series bold
figure 2
\series default
 shows the SP605 board.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/sp605.png
	lyxscale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spartan-6 SP605 Evaluation Kit
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source: http://www.xilinx.com/products/devkits/EK-S6-SP605-G.htm, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The support for the Spartan-6 LXT FPGA, digital video output interface,
 and 200MHz clock all make the SP605 a great choice for FPGA-based graphics
 acceleration.
 Additionally, its support for PCI-E makes it ideal for potential application
 in a desktop PC environment.
\end_layout

\begin_layout Subsubsection
Beagle Board
\end_layout

\begin_layout Standard
This project requires an embedded development system as a test platform
 for use with the FPGA-based GPU implementation.
 This test platform must meet the following requirements:
\end_layout

\begin_layout Enumerate
The platform must be a low-cost, low-power single-board computer (SBC)
\end_layout

\begin_layout Enumerate
The platform must be able to boot an embedded operating system (OS)
\end_layout

\begin_layout Enumerate
The platform must be fast enough to send graphics commands and data to the
 GPU in real-time
\end_layout

\begin_layout Enumerate
The platform must include a graphics chipset that can also render OpenGL
 ES 1.0 applications, for benchmarking purposes
\end_layout

\begin_layout Standard
The platform selected to fulfill these requirements was the Beagle Board,
 developed by Texas Instruments to demonstrate the the features of the OMAP3530
 system-on-a-chip (SoC).
 This SBC is both low-cost and low-power, retailing at only $149.00 USD per
 board.
\begin_inset CommandInset citation
LatexCommand cite
key "beagle1"

\end_inset

 The OMAP3530 meets both the second and third requirements, incorporating
 the ARM Cortex-A8 CPU, running at an impressive 720MHz and capable of booting
 Windows CE, Linux, and Symbian OSs.
 Lastly, the Beagle Board incorporates the PowerVR SGX chipset, a OpenGL
 ES 2.0 capable 2D/3D graphics accelerator capable of rendering 10 million
 polygons per second.
 Meeting the fourth requirement, this GPU would allow parallel rendering
 to benchmark the quantitative and qualitative performance of the FPGA implement
ation.
 Below, 
\series bold
figure 3
\series default
 shows the Beagle Board and highlights its major features.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/beagleBoard.png
	lyxscale 50
	scale 70
	BoundingBox 2bp 2bp 463bp 300bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The Beagle Board and its feature set
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source: http://www.beagleboard.org, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Project Overview and Design
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
This chapter presents a general overview of the project, discussing its
 goal and the objectives that must be met.
 Additionally, this chapter proposes a high level design, describing how
 to implement the project's various components and meet the necessary design
 requirements.
\end_layout

\begin_layout Subsection
Goal
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The main goal of this project is to implement a portable graphics accelerator
 on a FPGA.
 This device should provide single-chip 3D graphics acceleration for low-power
 and space-conscious environments, such as with mobile and embedded systems.
 Implemented in Hardware Description Language (HDL), this accelerator would
 be entirely open and configurable, providing a graphics system that could
 be easily adapted or optimized for specific system requirements.
\end_layout

\begin_layout Subsection
Objectives
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
To achieve the goal of this project, three primary objectives must be met:
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must provide a simple and fast interface for input
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must be able to generate an image at reasonable
 speeds from graphics data
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must provide a display output interface
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
These objectives will be completed through the design and implementation
 of a number of subsystems.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The first objective is for the device to be able to interface with other
 systems that need to display graphics.
 The device should be able to be easily connected to other systems through
 a standard input/output (IO) format.
 The device should use an easy and intuitive means of communication.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The second objective is the ability of the device to rasterize a two-dimensional
 (2D) image from the three dimensional (3D) data provided by another system.
 This must be highly efficient, as many images need to be generated per
 second to produce smooth animated visualizations.
 Consequently, optimal algorithms need to be selected to perform these operation
s on the target hardware.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The third and final objective is to provide a means to easily display the
 generated image.
 This means should adhere to a known display output format, allowing for
 the graphics accelerator to be used with many different system platforms.
 An output connection, as well as the underlying hardware controller for
 the selected format, should be provided.
\end_layout

\begin_layout Subsection
\paragraph_spacing onehalf
Design Requirements
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The design for this project includes 5 subsystems.
 These systems and their responsibilities are described below in 
\series bold
Table 1
\series default
.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Provide a cross-platform interface for graphics commands and data.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Graphics Processor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Render 3D primitive data to a 2D pixel buffer.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implement a standardized display output.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Graphics API
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Allow a user to easily send graphics data from their applications.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Device Driver
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Create the interface between software and the graphics hardware.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The major components of the design requirements
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
Each subsystem has its own specific requirements.
 The 
\shape italic
input interface
\shape default
 must provide a communication connection for graphics commands and data
 to the accelerator.
 This hardware implements the link between a host system and the the graphics
 processing unit (GPU).
 This interface must be independent of the platform used with the accelerator,
 adhering to a known and standardized IO format.
 This format must be able to transfer graphics commands and data at a fairly
 high rate while being compatible with a reasonable amount of low-power
 microprocessor and microcontroller systems.
 This is intended for easy application with a multitude of mobile platforms.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The 
\shape italic
graphics processor
\shape default
 shall render 3D primitive data to 2D space and will be fulfilled by the
 functional implementation of a GPU.
 The GPU must implement the 3D graphics pipeline and all of its components.
 The GPU must be able to receive encoded commands and data from the input
 interface, perform transformations on these, and rasterize the result to
 a raw pixel buffer.
 These components must run efficiently and integrate seamlessly with the
 desired input and output devices.
 The GPU must implement optimal rasterization and transformation algorithms
 that run in parallel to each other and achieve the highest possible speeds
 for the target platform.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
output interface
\shape default
 must implement a standardized display output, providing the interface between
 the GPU and a target output device.
 This interface must implement a digital video out standard ensuring that
 it could be used for multiple different displays.
 This requires a hardware implementation of the display format controller
 to generate necessary output signals.
 Furthermore, this requires the necessary hardware to provide a physical
 display output connection.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
graphics API
\shape default
 must define an abstraction layer that allows a user to easily send graphics
 commands and data to the accelerator from their applications.
 This API must be implemented in a standardized programming language and
 must follow a consistent and logical specification.
 The API must implement all configuration of all graphics features and settings
 of the accelerator.
 The API must also provide an intuitive interface for drawing and manipulating
 graphical data with the GPU.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
device driver
\shape default
 provides the software interface between the graphics API and the hardware
 input interface.
 The driver must implement the defined functionality of the API by sending
 commands and data to the input interface.
 This driver must be compatible with multiple hardware systems by being
 implemented within a standard driver model.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "reference_list"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
