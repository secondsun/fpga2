#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement H
\paperfontsize default
\spacing other 1.5
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
\paragraph_spacing single
\noindent
\begin_inset Graphics
	filename C:/Users/Eric/Documents/WPI/Academics/2009-2010/MQP/doc/image/wpiLogo.png
	lyxscale 25
	scale 25

\end_inset


\begin_inset Newline linebreak
\end_inset


\series bold
FPGA-Based Graphics Acceleration
\series default

\begin_inset Newline linebreak
\end_inset

Project Proposal
\end_layout

\begin_layout Author
\paragraph_spacing single
\noindent
Eric Nadeau
\begin_inset Newline newline
\end_inset

Skyler Whorton
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
\align right
Professor R.
 James Duckworth
\begin_inset Newline linebreak
\end_inset


\series bold
Major Advisor
\series default

\begin_inset Newline linebreak
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
\align right
Professor Emmanuel Agu
\begin_inset Newline linebreak
\end_inset


\series bold
Co-Advisor
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Itemize
TODO
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Background Research
\end_layout

\begin_layout Subsection
Portable Graphics
\end_layout

\begin_layout Subsubsection
Historical Context
\end_layout

\begin_layout Subsubsection
Applications
\end_layout

\begin_layout Itemize
Mobile Computing
\end_layout

\begin_layout Itemize
Embedded Systems
\end_layout

\begin_layout Subsubsection
Current ASIC Technology
\end_layout

\begin_layout Itemize
NVIDIA Tegra
\end_layout

\begin_layout Itemize
PowerVR SGX
\end_layout

\begin_layout Subsection
Graphics Rendering Pipeline
\end_layout

\begin_layout Standard
The graphics rendering pipeline traditionally refers to a generalized abstractio
n for the process that of which modern graphics processing units (GPUs)
 employ to produce visualizations.
 The GPU typically implements 6 stages within the pipeline, and often various
 substages within these.
 These 6 are: (1) the front end, (2) a vertex processing, (3) primitive
 assembly, (4) rasterization and interpolation, (5) fragment processing,
 and (6) frame buffer output.
 These stages all run in parallel, however it is important to note that
 data passes through each of them sequentially.
 Figure 1 below shows the graphics pipeline, as implemented by OpenGL:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename C:/Users/Eric/Documents/WPI/Academics/2009-2010/MQP/doc/image/graphicsPipeline.PNG
	lyxscale 50
	scale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A high level representation of the graphics pipeline used in realtime rendering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source Adapted from: NVIDIA Cg User's manual, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This figure shows all of the major components of the graphics rendering
 pipeline for modern GPUs.
 This pipeline typically starts at the front end, where commands and data
 are sent from a host system.
 The graphics data will then filter through the pipeline, while the GPU
 performs necessary processing and transformation to produce raw displayable
 data.
 The graphics commands typically control the how this processing and transformat
ion is done at the various stages.
 The output of this system is an image updating in realtime that can be
 drawn by a display device.
 This section describes the high level functionality of these stages, and
 how they interact with eachother.
\end_layout

\begin_layout Subsubsection
Front End
\end_layout

\begin_layout Subsubsection
Vertex Processing
\end_layout

\begin_layout Subsubsection
Primitive Assembly
\end_layout

\begin_layout Subsubsection
Rasterization and Interpolation
\end_layout

\begin_layout Subsubsection
Fragment Processing
\end_layout

\begin_layout Subsubsection
Frame Buffer
\end_layout

\begin_layout Subsection
3D Mathematics
\end_layout

\begin_layout Subsubsection
Transformation
\end_layout

\begin_layout Subsubsection
Fixed Point Algorithms
\end_layout

\begin_layout Standard
Floating-point units (FPUs), the components of CPUs used to natively perform
 arithmatic on floating point numbers, are often not available on FPGAs
 and few and far between on low-power micocontrollers and microprocessors.
 With these, floating point math may be implemented in software, or simply
 not used at all.
 On devices like these, reasoble computational performance can likely be
 achieved using fixed-point arithmatic for 3D mathematics rather than a
 software-defined FPU.
 For functional implementaton of fixed-point 3D computations, a number of
 steps must be followed depending on the calculation performed.
 This section describes the necessary background for these.
\end_layout

\begin_layout Subsection
Target Platforms
\end_layout

\begin_layout Subsubsection
Field Programmable Gate Arrays (FPGAs)
\end_layout

\begin_layout Itemize
Overview of technology
\end_layout

\begin_layout Itemize
Advantages and disadvantages for graphics acceleration
\end_layout

\begin_layout Subsubsection
Spartan-6 FPGA and SP601 Evaluation Kit
\end_layout

\begin_layout Itemize
Spartan-6 features
\end_layout

\begin_layout Itemize
SP601 Evaluation kit features
\end_layout

\begin_layout Itemize
Why selected
\end_layout

\begin_layout Subsubsection
Beagle Board
\end_layout

\begin_layout Standard
This project requires an embedded development system as a test platform
 for use with the FPGA-based GPU implementation.
 This test platform must meet the following requirements:
\end_layout

\begin_layout Enumerate
The platform must be a low-cost, low-power single-board computer (SBC)
\end_layout

\begin_layout Enumerate
The platform must be able to boot an embedded operating system (OS)
\end_layout

\begin_layout Enumerate
The platform must be fast enough to send graphics commands and data to the
 GPU in real-time
\end_layout

\begin_layout Enumerate
The platform must include a graphics chipset that can also render OpenGL
 ES 1.0 applications, for benchmarking purposes
\end_layout

\begin_layout Standard
The platform selected to fulfill these requirements was the Beagle Board,
 developed by Texas Instruments to demonstrate the the features of the OMAP3530
 system-on-a-chip (SoC).
 This SBC is both low-cost and low-power, retailing at only $149.00 USD per
 board.
\begin_inset CommandInset citation
LatexCommand cite
key "beagle1"

\end_inset

 The OMAP3530 meets both the second and third requirements, incorporating
 the ARM Cortex-A8 CPU, running at an impressive 720MHz and capable of booting
 Windows CE, Linux, and Symbian OSs.
 Lastly, the Beagle Board incorporates the PowerVR SGX chipset, a OpenGL
 ES 2.0 capable 2D/3D graphics accelerator capable of rendering 10 million
 polygons per second.
 Meeting the fourth requirement, this GPU would allow parallel rendering
 to benchmark the quantitative and qualitative performance of the FPGA implement
ation.
 Below, figure 2 shows the Beagle Board and highlights its major features.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename C:/Users/Eric/Documents/WPI/Academics/2009-2010/MQP/doc/image/beagleBoard.png
	lyxscale 50
	scale 75
	BoundingBox 2bp 2bp 463bp 300bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The Beagle Board and its feature set
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source: http://www.beagleboard.org, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Project Overview and Design
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
This chapter presents a general overview of the project, discussing its
 goal and the objectives that must be met.
 Additionally, this chapter proposes a high level design, describing how
 to implement the project's various components and meet the necessary design
 requirements.
\end_layout

\begin_layout Subsection
Goal
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The main goal of this project is to implement a portable graphics accelerator
 on a FPGA.
 This device should provide single-chip 3D graphics acceleration for low-power
 and space-conscious environments, such as with mobile and embedded systems.
 Implemented in Hardware Description Language (HDL), this accelerator would
 be entirely open and configurable, providing a graphics system that could
 be easily adapted or optimized for specific system requirements.
\end_layout

\begin_layout Subsection
Objectives
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
To achieve the goal of this project, three primary objectives must be met:
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must provide a simple and fast interface for input
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must be able to generate an image at reasonable
 speeds from graphics data
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must provide a display output interface
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
These objectives will be completed through the design and implementation
 of a number of subsystems.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The first objective is for the device to be able to interface with other
 systems that need to display graphics.
 The device should be able to be easily connected to other systems through
 a standard input/output (IO) format.
 The device should use an easy and intuitive means of communication.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The second objective is the ability of the device to rasterize a two-dimensional
 (2D) image from the three dimensional (3D) data provided by another system.
 This must be highly efficient, as many images need to be generated per
 second to produce smooth animated visualizations.
 Consequently, optimal algorithms need to be selected to perform these operation
s on the target hardware.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The third and final objective is to provide a means to easily display the
 generated image.
 This means should adhere to a known display output format, allowing for
 the graphics accelerator to be used with many different system platforms.
 An output connection, as well as the underlying hardware controller for
 the selected format, should be provided.
\end_layout

\begin_layout Subsection
\paragraph_spacing onehalf
Design Requirements
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The design for this project includes 5 subsystems.
 These systems and their responsibilities are described below in 
\series bold
Table 1
\series default
.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Provide a cross-platform interface for graphics commands and data.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Graphics Processor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Render 3D primitive data to a 2D pixel buffer.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implement a standardized display output.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Graphics API
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Allow a user to easily send graphics data from their applications.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Device Driver
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Create the interface between software and the graphics hardware.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The major components of the design requirements
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
Each subsystem has its own specific requirements.
 The 
\shape italic
input interface
\shape default
 must provide a communication connection for graphics commands and data
 to the accelerator.
 This hardware implements the link between a host system and the the graphics
 processing unit (GPU).
 This interface must be independent of the platform used with the accelerator,
 adhering to a known and standardized IO format.
 This format must be able to transfer graphics commands and data at a fairly
 high rate while being compatible with a reasonable amount of low-power
 microprocessor and microcontroller systems.
 This is intended for easy application with a multitude of mobile platforms.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The 
\shape italic
graphics processor
\shape default
 shall render 3D primitive data to 2D space and will be fulfilled by the
 functional implementation of a GPU.
 The GPU must implement the 3D graphics pipeline and all of its components.
 The GPU must be able to receive encoded commands and data from the input
 interface, perform transformations on these, and rasterize the result to
 a raw pixel buffer.
 These components must run efficiently and integrate seamlessly with the
 desired input and output devices.
 The GPU must implement optimal rasterization and transformation algorithms
 that run in parallel to each other and achieve the highest possible speeds
 for the target platform.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
output interface
\shape default
 must implement a standardized display output, providing the interface between
 the GPU and a target output device.
 This interface must implement a digital video out standard ensuring that
 it could be used for multiple different displays.
 This requires a hardware implementation of the display format controller
 to generate necessary output signals.
 Furthermore, this requires the necessary hardware to provide a physical
 display output connection.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
graphics API
\shape default
 must define an abstraction layer that allows a user to easily send graphics
 commands and data to the accelerator from their applications.
 This API must be implemented in a standardized programming language and
 must follow a consistent and logical specification.
 The API must implement all configuration of all graphics features and settings
 of the accelerator.
 The API must also provide an intuitive interface for drawing and manipulating
 graphical data with the GPU.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
device driver
\shape default
 provides the software interface between the graphics API and the hardware
 input interface.
 The driver must implement the defined functionality of the API by sending
 commands and data to the input interface.
 This driver must be compatible with multiple hardware systems by being
 implemented within a standard driver model.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "reference_list"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
