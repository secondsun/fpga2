#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement H
\paperfontsize default
\spacing other 1.5
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Title
\noindent
\begin_inset Graphics
	filename image/wpiLogo.png
	lyxscale 25
	scale 25

\end_inset


\begin_inset Newline linebreak
\end_inset


\series bold
FPGA-Based Graphics Acceleration
\series default

\begin_inset Newline linebreak
\end_inset

Project Proposal
\end_layout

\begin_layout Author
\paragraph_spacing single
\noindent
Eric Nadeau
\begin_inset Newline newline
\end_inset

Skyler Whorton
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
\align right
Professor R.
 James Duckworth
\begin_inset Newline linebreak
\end_inset


\series bold
Major Advisor
\series default

\begin_inset Newline linebreak
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
\align right
Professor Emmanuel Agu
\begin_inset Newline linebreak
\end_inset


\series bold
Co-Advisor
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Table of Contents}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{List of Figures}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{List of Tables}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Itemize
Portable graphics have many applications in mobile and embedded devices.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Background Research
\end_layout

\begin_layout Subsection
Portable Graphics
\end_layout

\begin_layout Subsubsection
Historical Context
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Applications
\end_layout

\begin_layout Itemize
Mobile Computing
\end_layout

\begin_layout Itemize
Embedded Systems
\end_layout

\begin_layout Subsubsection
Current ASIC Technology
\end_layout

\begin_layout Itemize
NVIDIA Tegra
\end_layout

\begin_layout Itemize
PowerVR SGX
\end_layout

\begin_layout Subsubsection
OpenGL ES
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
Graphics Rendering Pipeline
\end_layout

\begin_layout Standard
The graphics rendering pipeline traditionally refers to a generalized abstractio
n for the process that of which modern graphics processing units (GPUs)
 employ to produce visualizations.
 The GPU typically implements 6 stages within the pipeline, and often various
 substages within these.
 These 6 are: (1) the front end, (2) a vertex processing, (3) primitive
 assembly, (4) rasterization and interpolation, (5) fragment processing,
 and (6) frame buffer output.
 These stages all run in parallel, however it is important to note that
 data passes through each of them sequentially.
 Figure 1 below shows the graphics pipeline, as implemented by OpenGL:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/graphicsPipeline.PNG
	lyxscale 50
	scale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A high level representation of the graphics pipeline used in realtime rendering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source Adapted from: NVIDIA Cg User's manual, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This figure shows all of the major components of the graphics rendering
 pipeline for modern GPUs.
 This pipeline typically starts at the front end, where commands and data
 are sent from a host system.
 The graphics data will then filter through the pipeline, while the GPU
 performs necessary processing and transformation to produce raw displayable
 data.
 The graphics commands typically control the how this processing and transformat
ion is done at the various stages.
 The output of this system is an image updating in realtime that can be
 drawn by a display device.
 This section describes the high level functionality of these stages, and
 how they interact with eachother.
\end_layout

\begin_layout Subsubsection
Front End
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Vertex Processing
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Primitive Assembly
\end_layout

\begin_layout Standard
A primitive is one or more vertices making up a point, line, or polygon.
 This stage takes transformed vertices from modelview transformations during
 vertex processing stage to produce primitives.
 Primitives are then clipped to fit just within the viewport or view volume.
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Rasterization and Interpolation
\end_layout

\begin_layout Standard
In computer graphics, a raster image is a 2D array of discrete pixels that
 represent intensity samples.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 As such, 
\shape italic
rasterization
\shape default
 is the stage within the graphics rendering pipeline where a 2D image is
 generated from transformed primitive data.
 More formally, rasterization is defined as converting a line drawing, mathemati
cal expression in space, or a 3D scene into intensity values into an image
 buffer, and then propagating them to an output device.
 Within rasterization, 
\shape italic
interpolation
\shape default
 is the process of constructing new data points - in the form of color intensity
 values - within the discrete range connecting two vertexes.
 With computer graphics, interpolation is necessary for generating vertex
 colors and fog, among other things.
 
\end_layout

\begin_layout Standard
When creating a rasterizer, there are two main challenges that designers
 are often faced with: (1) To determine the pixel(s) that accurately describe
 the current primitive being rendered, and (2) to be efficient.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 Furthermore, rasterization includes the process of 
\shape italic
clipping
\shape default
, which eliminates primitives that do not need to be rendered to the display
 device.
 These bounds are typically referred to as the 
\shape italic
culling object
\shape default
.
 Lastly, within the rasterization stage, the 
\shape italic
Z-buffer
\shape default
 (depth buffer) is generated, which stores the depth values for rasterized
 pixels.
 For this project, rasterization of primitives is limited to simply points,
 lines, and triangles.
 This section describes ideal algorithms using fixed-point mathematics for
 rasterizing these, as well as proper methods of clipping and Z-buffer generatio
n.
 
\end_layout

\begin_layout Standard
TODO:
\end_layout

\begin_layout Itemize
Point rasterization algorithm
\end_layout

\begin_layout Itemize
Line rasterization algorithm
\end_layout

\begin_layout Itemize
Triangle rasterization algorithm
\end_layout

\begin_layout Itemize
Clipping algorithm(s)
\end_layout

\begin_layout Itemize
Z-Buffer
\end_layout

\begin_layout Subsubsection
Fragment Processing
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Frame Buffer
\end_layout

\begin_layout Standard
After the GPU has produced a synthesized image, and performed necessary
 pixel transformation on it, the pixels are stored in an image buffer -
 the 
\shape italic
frame buffer
\shape default
.
 As its name suggests, the frame buffer stores the current 
\begin_inset Quotes eld
\end_inset

frame
\begin_inset Quotes erd
\end_inset

 to be rendered, in reference to an animation sequence.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 This intermediate storage between the graphics pipeline and the output
 display is necessary because the two are not synchronized with eachother.
 Displays are typically clocked, which dependent on both the display resolution
 and refresh rate.
 Display updates are synchronous processes, performing continuously and
 sequentially by a constant clock signal.
 The GPU, on the other hand, produces data asynchronously and randomly,
 which is dependent on when the CPU sends it data or commands.
\end_layout

\begin_layout Standard
The frame buffer for a graphics accelerator is generally either preallocated
 in a systems main memory, or in a dedicated memory device onboard the graphics
 accelerator.
 Specifically, with realtime graphics systems, the frame buffer is where
 all pixel color data from rasterization is stored before being drawn to
 the display.
 Furthermore, this is necessary because rasterization is performed on primitives
 and there is no guarantee that the rasterized primitives are actually drawn
 to the output.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 For simplicity and efficiency, pixel color data within the framebuffer
 is typically encoded in a format most compatible with the input signals
 of the display device.
\end_layout

\begin_layout Standard
Unfortunately, due to the conclict between GPU's random access to the frame
 buffer and the display device's sequential access, many issues arrise.
 Primarily, it is very likely that the display device will begin reading
 a 
\shape italic
scanline
\shape default
, the a horizontal pixel line traced by a display's rasterbeam, before the
 GPU has finished drawing it.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 An ideal solution to this problem would be for the output circuit of the
 graphics accelerator to wait for the rendering of a frame to be completed
 before starting to read the frame buffer.
 However, this is not possible, as the output image must be updated at a
 very specific rate that is independent of rasterization time.
\end_layout

\begin_layout Standard
The solution to this problem is to introduce 
\shape italic
double buffering
\shape default
, the use of two frame buffers by the GPU.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 The first frame buffer, the back buffer, is used for writing only from
 the rasterizer, and can as such be written to randomly.
 The second framebuffer, the front buffer, is used only for reading from
 the output circuit, and can as such be read sequentially without respect
 to the time of which data is written.
 When the current frame is finished rendering to the back buffer, the two
 buffers then switch roles, and the next frame is drawn.
 This will prevent the buffer that is currently being drawn from ever being
 directly written to.
\end_layout

\begin_layout Standard
However, basic double buffering still may not correct all possible frame
 buffer related artifacts.
 The most common of these, 
\shape italic
tearing
\shape default
, occurs when the buffers swap before the sequential reading of the front
 buffer has not completed an entire frame.
\begin_inset CommandInset citation
LatexCommand cite
key "theoharis"

\end_inset

 This results in the lower portion of the display being a frame ahead from
 the upper portion.
 Tearing can be avoided by only buffer swapping in the refresh interval,
 the vertical blank count (VBLANK), between the previous and next frames.
 Swapping during the VBLANK period will, however, introduce a lag.
 On many modern graphics accelerators, this is a setting that can be disabled
 in order to maximize speed.
\end_layout

\begin_layout Subsection
3D Mathematics
\end_layout

\begin_layout Subsubsection
Transformation
\end_layout

\begin_layout Itemize
Model space: affine transformations such as scaling, rotation and translation
\end_layout

\begin_layout Itemize
View space: projection modes such as perspective and orthogonal
\end_layout

\begin_layout Subsubsection
Fixed-Point Computations
\end_layout

\begin_layout Standard
Floating-point units (FPUs), the components of CPUs used to natively perform
 arithmatic on floating point numbers, are often not available on FPGAs
 and few and far between on low-power micocontrollers and microprocessors.
 With these, floating point math may be implemented in software, or simply
 not used at all.
 On such devices, reasonable computational performance can likely be achieved
 using fixed-point arithmatic for 3D mathematics rather than a software-defined
 FPU.
\end_layout

\begin_layout Standard
With fixed-point arithmatic, the decimal point of a number is 
\begin_inset Quotes eld
\end_inset

fixed
\begin_inset Quotes erd
\end_inset

 before a specific digit.
 For example, during integer math, the decimal is placed after the least
 signicant bit (LSB), meaning that there is no memory allocated for a possible
 fraction.
 In this scenerio, the fraction is discarded and the result of a computation
 is rounded to simply whole numbers.
 However, it is possible to fix the decimal point at a different position
 within the number.
 This allows for fractions to be represented, even if they are still just
 rounded approximations.
 With this form of number representation, math can be done by a traditional
 arithmatic logic unit (ALU) and 3D vectors may still be approximated enough
 to render realistic visualizations.
 This incorporates simple integer math, along with some additional steps
 to account for the decimal point position.
 Depending on the operation performed, the following additional steps must
 be taken: 
\end_layout

\begin_layout Itemize

\series bold
Addition
\series default
- TODO
\end_layout

\begin_layout Itemize

\series bold
Subtraction
\series default
- TODO
\end_layout

\begin_layout Itemize

\series bold
Multiplication
\series default
- TODO
\end_layout

\begin_layout Itemize

\series bold
Division
\series default
- TODO
\end_layout

\begin_layout Standard
For the application of 3D mathematics, it is seldom ideal to represent fixed
 numbers with equal allocation for both whole numbers and fractions.
\begin_inset CommandInset citation
LatexCommand cite
key "pendleton"

\end_inset

This is due to the frequent need for a signed most significant bit (MSB),
 which constrains the integer component of the number.
 Instead, a format such as 18.14 or 17.15 (in the format M.N, where M represents
 the integer component in bits and N represents the fractional component
 in bits) is often much more usable for 32-bit 3D fixed-point math.
 For 16-bit math, the format 10.6 is ideal to allow for a substantial enough
 integer component.
\end_layout

\begin_layout Subsection
Target Platforms
\end_layout

\begin_layout Subsubsection
Field Programmable Gate Arrays (FPGAs)
\end_layout

\begin_layout Itemize
Overview of technology
\end_layout

\begin_layout Itemize
Advantages and disadvantages for graphics acceleration
\end_layout

\begin_layout Subsubsection
Spartan-6 FPGA and SP605 Evaluation Kit
\end_layout

\begin_layout Standard
The Spartan-6 is the latest iteration of Xilinx's Spartan family of low-cost,
 low-power FPGAs.
 Xilinx, the leading FPGA manufacturer, has designed the Spartan 6 with
 high performance and cost-sensitive applications in mind.
\begin_inset CommandInset citation
LatexCommand cite
key "spartan1"

\end_inset

 Using 45nm, 9-metal copper layer, dual-oxide process technology, the Spartan
 6 includes advanced power management and memory support, among other features.
 The selected LXT model includes 150,000 logic cells and supports integrated
 hard memory, block RAM, high performance clocking and serial IO, and an
 integrated PCI-Express (PCI-E) endpoint block.
 The Spartan-6 LTX is Xilinx's ideal offering for FPGA-based graphics accelerati
on as it balances both pricepoint and the resources necessary for GPU computatio
ns.
 
\end_layout

\begin_layout Standard
The SP605 Evaluation Kit enables developers to easily prototype designs
 with the Spartan-6 LXT FPGA.
 The kit includes all the basic components of the Xilinx Base Targeted Design
 Platform in one package.
 
\begin_inset CommandInset citation
LatexCommand cite
key "spartan1"

\end_inset

 With the SP605, developers can easily take advantage of the features of
 the Spartan 6.
 Additionally, the kit includes DVI video output, a 200MHz oscillator, 128MB
 of DDR3 memory, and various expansion connections.
 
\series bold
Figure 2
\series default
 shows the SP605 board.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/sp605.png
	lyxscale 50
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Spartan-6 SP605 Evaluation Kit
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source: http://www.xilinx.com/products/devkits/EK-S6-SP605-G.htm, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The support for the Spartan-6 LXT FPGA, digital video output interface,
 and 200MHz clock all make the SP605 a great choice for FPGA-based graphics
 acceleration.
 Additionally, its support for PCI-E makes it ideal for potential application
 in a desktop PC environment.
\end_layout

\begin_layout Subsubsection
Beagle Board
\end_layout

\begin_layout Standard
This project requires an embedded development system as a test platform
 for use with the FPGA-based GPU implementation.
 This test platform must meet the following requirements:
\end_layout

\begin_layout Enumerate
The platform must be a low-cost, low-power single-board computer (SBC)
\end_layout

\begin_layout Enumerate
The platform must be able to boot an embedded operating system (OS)
\end_layout

\begin_layout Enumerate
The platform must be fast enough to send graphics commands and data to the
 GPU in real-time
\end_layout

\begin_layout Enumerate
The platform must include a graphics chipset that can also render OpenGL
 ES 1.0 applications, for benchmarking purposes
\end_layout

\begin_layout Standard
The platform selected to fulfill these requirements was the Beagle Board,
 developed by Texas Instruments to demonstrate the the features of the OMAP3530
 system-on-a-chip (SoC).
 This SBC is both low-cost and low-power, retailing at only $149.00 USD per
 board.
\begin_inset CommandInset citation
LatexCommand cite
key "beagle1"

\end_inset

 The OMAP3530 meets both the second and third requirements, incorporating
 the ARM Cortex-A8 CPU, running at an impressive 720MHz and capable of booting
 Windows CE, Linux, and Symbian operating systems.
 Lastly, the Beagle Board incorporates the PowerVR SGX chipset, a OpenGL
 ES 2.0 capable 2D/3D graphics accelerator capable of rendering 10 million
 polygons per second.
 Meeting the fourth requirement, this GPU would allow parallel rendering
 to benchmark the quantitative and qualitative performance of the FPGA implement
ation.
 F
\series bold
igure 3
\series default
 shows the Beagle Board and highlights its major features.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/beagleBoard.png
	lyxscale 50
	scale 70
	BoundingBox 2bp 2bp 463bp 300bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The Beagle Board and its feature set
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center

\series bold
(Source: http://www.beagleboard.org, 2010)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Project Overview and Design
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
This chapter presents a general overview of the project, discussing its
 goal and the objectives that must be met.
 Additionally, this chapter proposes a high level design, describing how
 to implement the project's various components and meet the necessary design
 requirements.
\end_layout

\begin_layout Subsection
Goal
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The main goal of this project is to implement a portable graphics accelerator
 on a FPGA.
 This device should provide single-chip 3D graphics acceleration for low-power
 and space-conscious environments, such as with mobile and embedded systems.
 Implemented in Hardware Description Language (HDL), this accelerator would
 be entirely open and configurable, providing a graphics system that could
 be easily adapted or optimized for specific system requirements.
\end_layout

\begin_layout Subsection
Objectives
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
To achieve the goal of this project, three primary objectives must be met:
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must provide a simple and fast input interface
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must be able to generate an image at reasonable
 speeds from graphics data
\end_layout

\begin_layout Itemize
\paragraph_spacing onehalf
The graphics accelerator must provide a display output interface
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
These objectives will be completed through the design and implementation
 of a number of subsystems.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The first objective is for the device to interface with other systems that
 need to display graphics.
 The device should easily connect to other systems through a standard input/outp
ut (I/O) format, wherein it should use an easy and intuitive means of communicat
ion.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The second objective is the ability of the device to rasterize a two-dimensional
 (2D) image from the three dimensional (3D) data provided by another system.
 This must be accomplished efficiently because many images need to be generated
 per second to produce smooth animated visualizations.
 Consequently, the device must use optimal algorithms to perform these operation
s.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The third and final objective is to provide a means to display the generated
 image.
 This means should adhere to a standardized display format, allowing the
 graphics accelerator to be used with many different platforms.
 An output connection, as well as the underlying hardware controller for
 the selected format, should be provided.
\end_layout

\begin_layout Subsection
\paragraph_spacing onehalf
Design Requirements
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The design for this project includes 5 subsystems.
 These systems and their responsibilities are described in 
\series bold
Table 1
\series default
.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Provide a cross-platform interface for graphics commands and data.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Graphics Processor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Render 3D primitive data to a 2D pixel buffer.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output Interface
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implement a standardized display output.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Graphics API
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Allow a user to easily transmit graphics data from their applications.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Device Driver
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Provide the interface between software and the graphics hardware.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The major components of the design requirements
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
Each subsystem has its own specific requirements.
 The 
\shape italic
input interface
\shape default
 must provide a communication connection for graphics commands and data
 to the accelerator.
 This hardware implements the link between a host system and the the graphics
 processing unit (GPU).
 This interface must be independent of the platform used with the accelerator,
 adhering to a known and standardized I/O format.
 This format must be able to transfer graphics commands and data at a fairly
 high rate while being compatible with a reasonable amount of low-power
 microprocessor and microcontroller systems.
 This is intended for easy application with a multitude of mobile platforms.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
The 
\shape italic
graphics processor
\shape default
 shall render 3D primitive data to 2D space and will be fulfilled by the
 functional implementation of a GPU.
 The GPU must implement the 3D graphics pipeline and all of its components.
 The GPU must be able to receive encoded commands and data from the input
 interface, perform transformations on these, and rasterize the result to
 a raw pixel buffer.
 These components must run efficiently and integrate seamlessly with the
 desired input and output devices.
 The GPU must implement optimal rasterization and transformation algorithms
 that run in parallel to each other and achieve the highest possible speeds
 for the target platform.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
output interface
\shape default
 must implement a standardized display output, providing the interface between
 the GPU and a target output device.
 This interface must implement a digital video out standard ensuring that
 it could be used for multiple different displays.
 This requires a hardware implementation of the display format controller
 to generate necessary output signals.
 Furthermore, this requires the necessary hardware to provide a physical
 display output connection.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
graphics API
\shape default
 (Application Programming Interface) must define an abstraction layer that
 allows a user to easily send graphics commands and data to the accelerator
 from their applications.
 This API must be implemented in a standardized programming language and
 must follow a consistent and logical specification.
 The API must implement all configuration of all graphics features and settings
 of the accelerator.
 The API must also provide an intuitive interface for drawing and manipulating
 graphical data using the GPU.
\end_layout

\begin_layout Standard
\paragraph_spacing onehalf
\noindent
The 
\shape italic
device driver
\shape default
 provides the software interface between the graphics API and the hardware
 input interface.
 The driver must implement the defined functionality of the API by sending
 commands and data to the input interface.
 This driver must be compatible with multiple hardware systems by being
 implemented within a standard driver model.
 
\end_layout

\begin_layout Subsection
Design
\end_layout

\begin_layout Standard
This section describes the overall system design for the project, implementing
 the requirements previously discussed.
 The core of the system, the graphics processor and all of its necessary
 subsystems, will be implemented within the Spartan-6 LXT FPGA on the SP605
 Development Board.
 
\end_layout

\begin_layout Standard
To render 3D visualizations, data will flow first from the application,
 then to the graphics API and driver, and then to the FPGA.
 The FPGA will perform all necessary processing to rasterize the 3D visualizatio
ns to a framebuffer located in memory.
 The selected device to hold video memory is the 128MB DDR3 component memory,
 located on the SP605.
 Next, data from the framebuffer will be synchronously sent to the display
 device, using the SP605's Digital Video Interface (DVI) control circuitry.
 Figure 4 below provides a simple overall system diagram of the graphic
 hardware and its input and output interfaces.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/systemDiagram.png
	lyxscale 75
	scale 55
	BoundingBox 3bp 3bp 645bp 522bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
System overview
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Software Design Overview
\end_layout

\begin_layout Standard
The software design for this project implements all of the necessary abstraction
s for an application programmer to render 3D data with the graphics accelerator.
 This consists of two primary subsystems, (1) the graphics API and (2) the
 device driver.
 Additionally, the software designs for this project include various test
 modules whose purpose is to qualitatively and quantitatively benchmark
 the FPGA-based graphics accelerator against similiar performing ASIC-based
 graphics devices.
 
\end_layout

\begin_layout Paragraph
Graphics API
\end_layout

\begin_layout Standard
The graphics API is the software interface to the graphics hardware, allowing
 3D visualizations to be drawn for an application by envoking a logical
 and standardized set of functions.
 To be streamlined and hardware independent, the choice was made to implement
 OpenGL ES 1.0 as the graphics API, rather than designing a custom software
 interface.
 However, due to the limited scope of this project, only those functions
 that can be defined within the constraints of the graphics hardware features
 will be implemented.
 The remaining functions will be implemented as 
\begin_inset Quotes eld
\end_inset

stubs
\begin_inset Quotes erd
\end_inset

, allowing possible future expandability and for OpenGL ES applications
 to be compiled.
\end_layout

\begin_layout Paragraph*
Driver
\end_layout

\begin_layout Standard
The driver will perform all communication between the application (or operating
 system) and the graphics hardware.
 The driver will either run in (A) userspace or (B) kernel space, dependent
 on the chosen I/O format.
 Presently, potentially feasible I/O formats are being explored, including:
 General Purpose I/O (GPIO), Serial Peripheral Interface (SPI), PCI-Express,
 and Universal Serial Bus (USB).
 If implemented in kernel space, the driver will follow a known driver model
 (Linux or Windows).
 If implemented in userspace, the driver may potentially be implemented
 as a linked library to be included with an application utilizing the graphics
 hardware.
 This decision will be made once a final input interface platform is decided
 upon.
\end_layout

\begin_layout Paragraph*
Test Modules
\end_layout

\begin_layout Standard
The series of test modules will be written in order to qualitatively and
 quantitatively benchmark the graphics hardware.
 These will be written as 3D demos, and perform the following:
\end_layout

\begin_layout Itemize
Identify the maximum performance limitations of the graphics hardware, and
 produce reports on these (triangles-per-second, etc.)
\end_layout

\begin_layout Itemize
Implement tests to demonstrate and validate each individual feature of the
 graphics hardware
\end_layout

\begin_layout Itemize
Create a final, presentable, 3D visualization that takes full advantage
 of the graphics hardware to produce an animated scene, demonstrating all
 of the capabilities of the system
\end_layout

\begin_layout Subsubsection
RTL Design Overview
\end_layout

\begin_layout Standard
The Register Transfer Level (RTL) design for the graphics accelerator implements
 a number of subsystems to control the various stages of the graphics pipleline
 and its necessary input and output interfaces.
 
\series bold
Figure 5
\series default
 below provides a system diagram for the RTL hardware design of the project.
 This system performs the necessary steps to render 3D graphics to an output
 display device from an input command stream, provided by the host controller,
 a microcontroller or a microprocesser system.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename image/rtl_overview.png
	lyxscale 70
	scale 60
	BoundingBox 5bp 5bp 765bp 660bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
RTL design overview
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To control the graphics accelerator, commands must first be pushed into
 the GPU by the device driver running on the host system, followed directly
 by any relevant data.
 The GPU then disperses the commands and data to the necessary subsystems,
 specifically the 
\shape italic
Vertex and Transformation Unit
\shape default
 (VTU) and the 
\shape italic
Rasterizer
\shape default
 (RAS).
 These two units run in parallel, albeit sequentially on data.
 Transformed and rasterized data are then read sequentially by the 
\shape italic
Video Interface
\shape default
 (VI), which runs independently of the other subsystems, constantly refreshing
 the output display device signals.
 Below shows an example execution for a program that draws simple 3D primitives
 with the proposed implemention.
\end_layout

\begin_layout Enumerate
Initialization routine
\end_layout

\begin_deeper
\begin_layout Enumerate
Set clear color and depth values
\end_layout

\begin_layout Enumerate
Set viewport
\end_layout

\begin_layout Enumerate
Set view transformation mode (perspective, orthogonal)
\end_layout

\end_deeper
\begin_layout Enumerate
Draw primitives
\end_layout

\begin_deeper
\begin_layout Enumerate
Translate, scale, and rotate the modelview matrix
\end_layout

\begin_layout Enumerate
Send vertex position and color data
\end_layout

\end_deeper
\begin_layout Enumerate
Wait for vertical synchronization
\end_layout

\begin_layout Enumerate
Repeat steps 2 and 3
\end_layout

\begin_layout Paragraph
Graphics Processing Unit
\end_layout

\begin_layout Standard
The GPU processes the stream of data and commands (instructions) sent to
 the graphics accelerator.
 Acting as the frontend for the entire system, the GPU implements the various
 instructions needed to control the states of the remaining subsystems and
 draw primitive data.
 These instructions are queued into the GPU by a First-In First-Out (FIFO)
 buffer, and decoded and executed sequentially by the GPU.
 Consequently, the FIFO stores the sequence of instructions to be executed,
 as well as the necessary data these commands provide to the graphics accelerato
r.
 The GPU instruction set that defines all control over the graphics accelerator
 is presented below.
 
\end_layout

\begin_layout Standard
\paragraph_spacing single
\noindent
\begin_inset Tabular
<lyxtabular version="3" rows="27" columns="3">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
Opcode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
00h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
NOP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
No operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
01h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DISPCNT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set GPU control register
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
02h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DISPSTAT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set GPU status register
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
03h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
DRAWDONE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Denotes the end of a frame being drawn (swaps buffers)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
04h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VIEWPORT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Sets the viewport
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
05h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLEAR_COLOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Sets the clear color
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
06h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
CLEAR_DEPTH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Sets the clear depth
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
07h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
PIXEL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Draws a pixel directly to the framebuffer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
10h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_MODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set the current matrix mode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
11h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_PUSH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Push current matrix onto the stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
12h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_POP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Pop current matrix from the stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
13h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_STORE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Store current matrix on the stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
14h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_LOAD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Load current matrix from the stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
15h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_LOAD_I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Load current matrix with the identity matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
16h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_LOAD_4x4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Load a 4x4 matrix to the current matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
17h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_MULT_4x4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Multiply current matrix by a 4x4 matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
18h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_SCALE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Multiply current matrix by a scale matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
19h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
MTX_TRANS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Multiply current matrix by a translation matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
20h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_BEGIN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Begin a vertex list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
21h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_END
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
End a vertex list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
22h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_ATTRIB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set the attributes of the next vertex list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
23h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_POS_U16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set XYZ vertex coordinates, unsigned 16-bit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
24h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_POS_S16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set XYZ vertex coordinates, signed 16-bit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
25h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_POS_REL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set XYZ vertex coordinates, relative to the last vertex
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
26h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
VTX_COL_5551
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Set RGBA vertex color, 5551 mode (16-bit)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
For the graphics accelerator to process a command, the opcode must first
 be sent to the FIFO, followed by its necessary fields.
 
\end_layout

\begin_layout Paragraph
Vertex and Transformation Unit
\end_layout

\begin_layout Standard
The Vertex and Transformation Unit defines two primary subsystems, (1) the
 Matrix Processor (MP), and (2) the Geometry Processor (GP).
 All VTX and MTX commands decoded by the GPU are processed by the VTU.
 
\end_layout

\begin_layout Standard
The Matrix Processor implements all matrix commands, as well as the two
 matrix stacks (modelview and projection), and stores the corresponding
 current matrices.
 The matrix stacks are stored in video RAM (VRAM) and each contain space
 for up to 256 stored matrices.
 Consequently, the stack is addressed by an 8-bit stack pointer.
 The MP implements all of its matrix transformations by multiplying the
 current matrix by another matrix, which can be defined for translation,
 scaling, rotation, or orthogonal and perspective projection.
 All matrices are 4x4 32-bit fixed point, with the fractional part in the
 lower 12 bits (signed 20.12 format).
\end_layout

\begin_layout Standard
The Geometry Processor performs all of the necessary routines to prepare
 incoming vertice streams to be rasterized to the frame buffer.
 Upon receiving a VTX_BEGIN command, the GP begins processing a vertex list
 of the specified primitive type (points, lines, or triangles).
 To do this, the VTU envokes the following sequence of events:
\end_layout

\begin_layout Enumerate
Upon receiving the VTX_BEGIN command, the VTU enters geometry processing
 mode, and cannot receive any non-VTX commands until completion.
\end_layout

\begin_layout Enumerate
The VTU then receives the VTX_ATTRIB command (or otherwise uses data from
 the most recently received VTX_ATTRIB) to specify how the primitives are
 to be processed.
\end_layout

\begin_layout Enumerate
The VTU then receives a VTX_POS command for the specified X, Y, and Z vertices
 of a primitive, and executes the following:
\end_layout

\begin_deeper
\begin_layout Enumerate
Transform the X, Y, and Z vertices of the primitive by the modelview matrix
 (using the matrix multiplier)
\end_layout

\begin_layout Enumerate
Transform the X, Y, and Z vertices of the primitive by the projection matrix
 (using the matrix multiplier)
\end_layout

\begin_layout Enumerate
Write the resulting 2D primitive X and Y values to vertex bank 0 (VBANK0)
 in VRAM if it is within the bounds of the framebuffer.
\end_layout

\begin_layout Enumerate
Write the Z distance from the current view to VBANK0.
\end_layout

\begin_layout Enumerate
Write the vertex color from the corresponding VTX_COL command immediately
 after the transformed X, Y, and Z values.
\end_layout

\end_deeper
\begin_layout Enumerate
The VTU then repeats step 3 for the remaining vertices that have been sent.
\end_layout

\begin_layout Enumerate
The VTU then exits geometry processing mode upon receiving the VTX_END command.
\end_layout

\begin_layout Standard
At the completion of all drawing, the VTU will wait for being signaled that
 drawing of the current frame is completed with the DRAWDONE command.
 At this time, VBANK0 and VBANK1 will be swap addresses, indicating that
 the data in VBANK1 is ready to be rasterized.
 The data in the new VBANK0 are then cleared before new writes from the
 GP occur.
\end_layout

\begin_layout Paragraph
Rasterizer
\end_layout

\begin_layout Standard
The Rasterizer's main purpose is to perform all of the drawing to the framebuffe
r.
 The RAS performs this in two steps, (1) primitive rasterization, the process
 of computing the necessary pixels to be written to approximate points,
 lines, and triangles, and (2) color rasterization, the process of deteriming
 the necessary pixel color via interpolation.
 The rasterizer reads data from VBANK1 upon being signaled by the DRAWDONE
 command from the GPU.
 At this time, the RAS rasterizes all vertices in VBANK1 to the framebuffer,
 envoking the necessary rastization algorithm depending on the current primitive
 type.
 
\end_layout

\begin_layout Standard
Before pixels are actually written to the framebuffer, the RAS compares
 the Z-distance from the view of the current vertex (stored in VBANK1) to
 the Z-value of the current pixel being drawn in the Z-buffer (stored in
 VRAM).
 If the pixel to be drawn is further away from the current view than the
 value in the Z-buffer, then it is not drawn to the framebuffer.
 If it is closer, than it is drawn, and the value in the Z-buffer is overwritten
 with the new Z value.
 This implements simple depth-sorting.
 The Z-buffer is then cleared at the end of the frame.
 
\end_layout

\begin_layout Standard
Upon completion of rasterization, the rasterizer then waits until the Video
 Interface enters the vertical blanking period, the time between two frames
 are being drawn to the display device.
 During this window, framebuffers 0 and 1 swap addresses, and the new framebuffe
r 0 is subsequently cleared.
 The Rasterizer then waits for the next DRAWDONE to begin rasterizing the
 next frame to this buffer.
\end_layout

\begin_layout Paragraph*
Video Interface
\end_layout

\begin_layout Standard
The Video Interface provides all of the necessary interfacing to the output
 display device.
 This primarily includes, (1) timing synchronization of the whole system
 with the display rate, and (2) sequential generation of the RGB signals
 to the output display device from framebuffer 1.
 The VI operations completely independent of the entire system on its own
 60 frames-per-second (FPS) clock, constantly outputting the data from framebuff
er 1 synchronously with the vertical and horizontal timing signals.
 The VI feeds back a single active-high control signal to the GPU, indicating
 when it is in the VBLANK phase, for synchronization purposes.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "reference_list"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
